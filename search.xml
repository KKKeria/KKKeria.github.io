<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>回溯</title>
    <url>/2021/10/26/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="17电话号码的字母组合"><a href="#17电话号码的字母组合" class="headerlink" title="17电话号码的字母组合"></a>17电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。(九键输入法)</p>
<p>思路：九宫格每个数字（2-9）分别对应相应的字母 很显然要用哈希表将他们联系起来</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>          &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>      &#125;;<br></code></pre></td></tr></table></figure>
<p>因为是要求出所有的可能，首先想到的就是递归,回溯,dfs.代码分为两块</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> == <span class="hljs-built_in">digits</span>.<span class="hljs-built_in">size</span>()) &#123;<br>          res.push_back(tmp);<br>      &#125; //长度够了后返回结果<br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">char digit = digits[index]; <span class="hljs-regexp">//</span>输入数字的索引<br>string letters = pair[digit];<span class="hljs-regexp">//</span>输入数字对应的字母的字符串<br><span class="hljs-keyword">for</span>(auto l : letters) &#123; <span class="hljs-regexp">//</span>对每一个遍历<br>    tmp.push_back(l);<span class="hljs-regexp">//</span>tmp数组push <span class="hljs-string">&#x27;l&#x27;</span><br>    dfs(pair,index + <span class="hljs-number">1</span>,digits); <span class="hljs-regexp">//</span>递归 index++表示着要和下一个数字匹配<br>    tmp.pop_back();<span class="hljs-regexp">//</span>回溯（关键） 有点类似于树<br>&#125; <span class="hljs-regexp">//</span>处理过程<br></code></pre></td></tr></table></figure>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>            &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(pair,<span class="hljs-number">0</span>,digits);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair,<span class="hljs-keyword">int</span> index,string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">char</span> digit = digits[index];<br>        string letters = pair[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : letters) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(l);<br>            <span class="hljs-built_in">dfs</span>(pair,index + <span class="hljs-number">1</span>,digits);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22括号生成"><a href="#22括号生成" class="headerlink" title="22括号生成"></a>22括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<p>思路:有了上一个题的经验,但是这个没有什么需要处理的，直接进入dfs环节（因为只有左右括号一说）<br>还是分为两块</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(tmp.size() == n * <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.push_back</span>(tmp);<br>      &#125;<span class="hljs-comment">//因为是左右括号，每添加一次就会++ 而给的n代表的是括号对数</span><br></code></pre></td></tr></table></figure>
<p>然后又到了如何处理和回溯阶段</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">		<span class="hljs-selector-tag">if</span>(left &lt; n) &#123;<span class="hljs-comment">//首先只要左括号数小于n 一直加左括号 直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125;<br>        <span class="hljs-selector-tag">if</span>(right &lt; left) &#123;<span class="hljs-comment">//直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125; <span class="hljs-comment">//同样这两个都是用pop_back进行回溯</span><br><span class="hljs-comment">//过程大概就是 左括号三个 对应的右括号的情况 然后两个左括号在对应有括号（右括号必须小于左括号）</span><br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &lt; n) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; left) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="37解数独"><a href="#37解数独" class="headerlink" title="37解数独"></a>37解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 遵循如下规则：<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>思路：乍一看这个题是困难题,而且貌似非常复杂,其实也要遵循“标准”步骤<br>同样的道理,没有需要处理的就直接进入dfs</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//因为这个的停止条件就是遍历完全部，所以省去第一步 直接到如何处理和回溯</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-comment">//双层for找到需要判断的&quot;格子&quot;</span><br>               <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//不是空格就继续</span><br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123; <span class="hljs-comment">//假如是空格，这里有点类似第一个的 &#x27;2&#x27;代表 &quot;abc&quot; 这里的空格代表 0 - 9</span><br>                   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<span class="hljs-comment">//这里是题目的条件，要求填入的数合法,在回溯问题中可视为已知，这就可以类比为普通的dfs问题</span><br>                       board[i][j] = ch;<span class="hljs-comment">//填上相应数字</span><br>                       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//递归，如果最后返回true就说明有解</span><br>                       board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//回溯 </span><br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>判断的函数也是非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(board);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<br>                        board[i][j] = ch;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs回溯</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>4.9-力扣-780到达终点(困难)</title>
    <url>/2022/04/09/4-9-%E5%8A%9B%E6%89%A3-780%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-%E5%9B%B0%E9%9A%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。<br>从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过要求可以看出 (x,y) -&gt; (x, x + y) 或者 (x + y, y);那么可以反推得<br>(tx,ty) 的前身一定是(tx - a, ty) 或者(tx, ty - a) 其中a是上一层的tx或者ty;<br>以测试用例1来说明</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br>输入: sx = <span class="hljs-number">1</span>, sy = <span class="hljs-number">1</span>, tx = <span class="hljs-number">3</span>, ty = <span class="hljs-number">5</span><br>输出: <span class="hljs-literal">true</span><br>解释:<br>可以通过以下一系列转换从起点转换到终点：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">tx		ty<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span><br>.		.<br>.		.<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span> <span class="hljs-comment">% 3 //因为这里可以加相同的tx无数次来达到ty</span><br>.		.<br>.		.<br><span class="hljs-number">3</span> <span class="hljs-comment">% 2	2//同理 此时已经有了一边和sx 或者 sy相等，也就是从二元变成了一元，只需判断能否除余得0即可</span><br>[注]一定是大的除余小的，原因很简单......<br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reachingPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sx, <span class="hljs-keyword">int</span> sy, <span class="hljs-keyword">int</span> tx, <span class="hljs-keyword">int</span> ty)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tx &lt; sx || ty &lt; sy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (tx &gt; ty) &#123;<br>            <span class="hljs-keyword">if</span> (sy == ty)    <br>                <span class="hljs-keyword">return</span> sx &gt;= (tx % ty) &amp;&amp; (tx - sx) % sy == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx % ty, ty);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tx &lt; ty)&#123;<br>            <span class="hljs-keyword">if</span> (sx == tx)    <br>                <span class="hljs-keyword">return</span> sy &gt;= (ty % tx) &amp;&amp; (ty - sy) % sx == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx, ty % tx);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tx == sx &amp;&amp; ty == sy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/11/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/img/Lambda.png" alt="lena"></p>
<h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表[]"></a>捕获列表[]</h2><p>捕获列表是零或多个捕获符的逗号分隔符列表，可选地以默认捕获符开始（仅有的默认捕获符是 &amp; 和 = ）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ ]</span>。空捕获列表，lambda不能使用所在函数中的变量。<br><span class="hljs-selector-attr">[=]</span>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。<br><span class="hljs-selector-attr">[&amp;]</span>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。<br><span class="hljs-selector-attr">[this]</span>。函数体内可以使用Lambda所在类中的成员变量。<br><span class="hljs-selector-attr">[a]</span>。将<span class="hljs-selector-tag">a</span>按值进行传递。按值进行传递时，函数体内不能修改传递进来的<span class="hljs-selector-tag">a</span>的拷贝，因为默认情况下函数是const的。要修改传递进来的<span class="hljs-selector-tag">a</span>的拷贝，可以添加mutable修饰符。<br><span class="hljs-selector-attr">[&amp;a]</span>。将<span class="hljs-selector-tag">a</span>按引用进行传递。<br><span class="hljs-selector-attr">[=，&amp;a, &amp;b]</span>。除<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>按引用进行传递外，其他参数都按值进行传递。<br><span class="hljs-selector-attr">[&amp;, a, b]</span>。除<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>按值进行传递外，其他参数都按引用进行传递。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++知识</category>
      </categories>
  </entry>
  <entry>
    <title>edge扩展</title>
    <url>/2022/07/26/edge%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="edge不能下载扩展的解决方法"><a href="#edge不能下载扩展的解决方法" class="headerlink" title="edge不能下载扩展的解决方法"></a>edge不能下载扩展的解决方法</h2><h3 id="1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com"><a href="#1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com" class="headerlink" title="1- https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com"></a>1- <a href="https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com">https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com</a></h3><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">打开此网站，选择延迟较低<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure>
<h3 id="2-C-Windows-System32-drivers-etc"><a href="#2-C-Windows-System32-drivers-etc" class="headerlink" title="2- C:\Windows\System32\drivers\etc"></a>2- C:\Windows\System32\drivers\etc</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">找到此路径下的hosts文件，在最先面添加 <br><span class="hljs-number">116.55</span>.<span class="hljs-number">252.94</span> msedgeextensions<span class="hljs-selector-class">.sf</span><span class="hljs-selector-class">.tlu</span><span class="hljs-selector-class">.dl</span><span class="hljs-selector-class">.delivery</span><span class="hljs-selector-class">.mp</span><span class="hljs-selector-class">.microsoft</span><span class="hljs-selector-class">.com</span> #Edge商店扩展<br><span class="hljs-selector-attr">[注]</span>前面为复制的ip 后面是商店扩展的url，如果别的有问题也可以替换为别的<br></code></pre></td></tr></table></figure>
<h3 id="3-管理员身份打开cmd-输入-ipconfig-flushdns"><a href="#3-管理员身份打开cmd-输入-ipconfig-flushdns" class="headerlink" title="3- 管理员身份打开cmd 输入 ipconfig /flushdns"></a>3- 管理员身份打开cmd 输入 ipconfig /flushdns</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">客户端查询DNS的过程是：<br><br>本地host文件—本地缓存—-DNS服务器<br><br>Ｈost文件用于本地DNS解析，并且优先于寻找网络上的DNS服务器<br><br>在Windows中，它的目录通常在[Windows目录]\system32\drivers\etc\下。<br><br><span class="hljs-symbol">Hosts</span>文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/<span class="hljs-built_in">IP</span> for Windows 的标准来工作的，它的作用是包含<span class="hljs-built_in">IP</span>地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，<span class="hljs-built_in">IP</span>地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> localhost.<br><br>我们知道，当电脑访问网站时，首先通过DNS服务器把网络 域名解析成<span class="hljs-built_in">IP</span>地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回<span class="hljs-built_in">IP</span>，访问速度就会比较慢，而Hosts文件正可以解决这个 问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个<span class="hljs-built_in">IP</span>地址映射，如果没有再向DNS服 务器提出域名解析。<br><br>对于要经常访问的网站和用于测试服务，我们可以通过在Hosts中配置域名和<span class="hljs-built_in">IP</span>的映射关系，这样当我们输入域名计算机就能很快解析出<span class="hljs-built_in">IP</span>，而不用请求网络上的DNS服务器。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>-edge</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/11/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="第-267-场周赛-5929-处理含限制条件的好友请求"><a href="#第-267-场周赛-5929-处理含限制条件的好友请求" class="headerlink" title="第 267 场周赛 5929. 处理含限制条件的好友请求"></a>第 267 场周赛 5929. 处理含限制条件的好友请求</h2><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。<br>一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p>
<span id="more"></span>
<h2 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <span class="hljs-keyword">int</span> n;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">parent</span>(_n), <span class="hljs-built_in">size</span>(_n, <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(), parent.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<span class="hljs-comment">//给parent累加赋值 0,1,2......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">//找到x的最高树节点</span><br>        <span class="hljs-keyword">return</span> parent[x] == x ? x : parent[x] = <span class="hljs-built_in">findset</span>(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//成为朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-comment">//已经是就不用操作</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y]) &#123;并查集，维护树高，把矮的往高的合并再加上路径优化可以得到最优的复杂度<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//判断是否是朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="题目实现代码-注释"><a href="#题目实现代码-注释" class="headerlink" title="题目实现代码 + 注释"></a>题目实现代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">friendRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; re, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; qu)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt; res;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//初始化并查集类 并且赋初值n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qu.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//遍历每一个成为朋友的请求request</span><br>            <span class="hljs-keyword">int</span> x = qu[i][<span class="hljs-number">0</span>], y = qu[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// x,y分别获取值</span><br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用于判断能否成为朋友，即是否被限制（restrictions）</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">connected</span>(x, y))&#123;<span class="hljs-comment">//如果不满足这个条件说明两个人已经是朋友，就不用了进行判断，直接push_back</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; re.<span class="hljs-built_in">size</span>(); ++j)&#123;<span class="hljs-comment">//如果满足就对每一条限制(resstriction)进行判断</span><br>                    <span class="hljs-keyword">int</span> p = re[j][<span class="hljs-number">0</span>], q = re[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>((uf.<span class="hljs-built_in">connected</span>(p, x) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, y))<br>                      || (uf.<span class="hljs-built_in">connected</span>(p, y) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, x)))&#123;<span class="hljs-comment">//限制条件 P-X &amp;&amp; Q-Y则 X-Y不能成立</span><br>                        f = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果存在一种不能成立的 就让f = false 代表不能成为朋友</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)&#123; <span class="hljs-comment">//true就 unite(让两个成为朋友) push_back true;</span><br>                uf.<span class="hljs-built_in">unite</span>(x, y);<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则就 push_back false;</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>最小堆（优先队列 priority_queue）</title>
    <url>/2021/11/03/%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20priority_queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="11-03-407-接雨水-II"><a href="#11-03-407-接雨水-II" class="headerlink" title="11-03 407. 接雨水 II"></a>11-03 407. 接雨水 II</h2><p>给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<span id="more"></span>
<p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的。我们可以知道容器内水的高度取决于最外层高度最低的方块，如图所示：<br><img src="/img/P1.png" alt="来自LeetCode"><br>我们假设已经知道最外层的方块接水后的高度的最小值，则此时我们根据木桶原理，肯定可以确定最小高度方块的相邻方块的接水高度。<br>我们同时更新外层的方块标记，我们在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度，如图所示:<br><img src="/img/P2.png" alt="来自LeetCode"><br>然后再次更新最外层，依次迭代直到求出所有的方块的接水高度，即可知道矩阵中的接水容量。 这里使用到了一种数据结构—最小堆</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆也叫优先队列，堆是一种特殊的完全二叉树数据结<br>堆分为两种，最大堆，最小堆。<br>最大堆：根节点大于左右两个子节点的完全二叉树<br>最小堆：根节点小于左右两个子节点的完全二叉树<br>堆可以用数组来存储，<br>a[i]处存根节点，a[2 * i]存左子树的根节点 ; a[2 * i + 1]存右子树的根节点。i从1开始!!<br><img src="/img/P3.png" alt="完全二叉树"></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++ STL实现的优先级队列是一种容器适配器，类似堆，可以随时插入元素，但只能检索到优先级队列中优先级最高的元素。<br>priority_queue&lt;int,vector,less&gt; q;最大堆（默认为最大堆）<br>priority_queue&lt;int,vector,greater&gt; q;最小堆</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; small_heap; <span class="hljs-comment">//最小堆定义方法</span><br>第一个参数T：元素（element）类型<br>第二个参数Container：必须是容器类型Container，用来存储元素（element），其类型必须是第一个参数<br>第三个参数Compare：比较形式，默认是less<br><br>q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回q里元素个数</span><br>q.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.<span class="hljs-built_in">push</span>(k);<span class="hljs-comment">//在q的末尾插入k</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure>

<h2 id="完整代码-详细注释"><a href="#完整代码-详细注释" class="headerlink" title="完整代码 + 详细注释"></a>完整代码 + 详细注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trapRainWater</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> row = heightMap.<span class="hljs-built_in">size</span>(), col = heightMap[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">3</span> || col &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//不足 3X3不可能接到水</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; minHeap;<span class="hljs-comment">//最小堆定义，</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == row - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == col - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//最外围一圈不可能接到水，先入队列</span><br>                    minHeap.<span class="hljs-built_in">push</span>(&#123;heightMap[i][j], i * col + j&#125;);<span class="hljs-comment">//i * col + j以这种方式存储</span><br>                    vis[i][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//vis数组来记录访问</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; direction =  &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向--左、上、右、下</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; tmp = minHeap.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//定义一个临时变量获取队列top()值</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">//四个方向分别遍历</span><br>                <span class="hljs-keyword">int</span> nextrow = tmp.second / col + direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> nextcol = tmp.second % col + direction[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//下一个的坐标 i，j值，承接上面的存储方法</span><br><br>            <span class="hljs-keyword">if</span>(nextrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nextrow &lt; row &amp;&amp; nextcol &gt;= <span class="hljs-number">0</span> &amp;&amp; nextcol &lt; col &amp;&amp; !vis[nextrow][nextcol]) &#123; <span class="hljs-comment">//首先得在范围内 并且未被访问</span><br>                    <span class="hljs-keyword">if</span>(heightMap[nextrow][nextcol] &lt; tmp.first) &#123; <span class="hljs-comment">//最小堆的特性，最小值，如果符合条件就说明存在“木桶” </span><br>                        res += tmp.first - heightMap[nextrow][nextcol];<span class="hljs-comment">//结果加上</span><br>                    &#125;<br>                vis[nextrow][nextcol] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//代表已经访问</span><br>                minHeap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">max</span>(heightMap[nextrow][nextcol], tmp.first), nextrow * col + nextcol&#125;);<span class="hljs-comment">//访问后放入最小堆</span><br>                &#125;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>对象创建限制在堆或栈</title>
    <url>/2021/11/25/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%99%90%E5%88%B6%E5%9C%A8%E5%A0%86%E6%88%96%E6%A0%88/</url>
    <content><![CDATA[<p>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>C++ 中的类的对象的建立分为两种：静态建立、动态建立。<br>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;<br>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</p>
<span id="more"></span>
<h2 id="限制对象只能建立在堆上"><a href="#限制对象只能建立在堆上" class="headerlink" title="限制对象只能建立在堆上"></a>限制对象只能建立在堆上</h2><h3 id="最直观的思想：避免直接调用类的构造函数"><a href="#最直观的思想：避免直接调用类的构造函数" class="headerlink" title="最直观的思想：避免直接调用类的构造函数"></a>最直观的思想：避免直接调用类的构造函数</h3><p>因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
<h3 id="解决方法-1："><a href="#解决方法-1：" class="headerlink" title="解决方法 1："></a>解决方法 1：</h3><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">public</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">destory</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br><span class="hljs-attr">private</span>:<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>该方法存在的问题：<br>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
<h3 id="解决方法-2："><a href="#解决方法-2：" class="headerlink" title="解决方法 2："></a>解决方法 2：</h3><p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">protected</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br><span class="hljs-attr">public</span>:<br>    <span class="hljs-keyword">static</span> A *<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">destory</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="限制对象只能建立在栈上"><a href="#限制对象只能建立在栈上" class="headerlink" title="限制对象只能建立在栈上"></a>限制对象只能建立在栈上</h2><p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">private</span>:<br>    <span class="hljs-keyword">void</span> *operator <span class="hljs-function"><span class="hljs-title">new</span>(<span class="hljs-params">size_t t</span>)</span> &#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-keyword">void</span> operator <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ptr</span>)</span> &#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-attr">public</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>C++知识</category>
      </categories>
  </entry>
  <entry>
    <title>洗牌算法-随机打乱数组</title>
    <url>/2021/11/22/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>Inside-Out Algorithm 算法的基本思路是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k）<br>这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p>
<span id="more"></span>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">RandomAccessIterator</span>&gt;                                             <br><span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">random_shuffle</span>(<span class="hljs-symbol">RandomAccessIterator</span> <span class="hljs-symbol">first, <span class="hljs-symbol">RandomAccessIterator</span></span> <span class="hljs-symbol">last</span>) &#123; <br>    <span class="hljs-keyword">if</span>(first != last)                                                             <br>        <span class="hljs-keyword">for</span>(RandomAccessIterator i = first + <span class="hljs-number">1</span>; i != last; ++i)                   <br>            iter_swap(i, first + (rand() % ((i - first) + <span class="hljs-number">1</span>)));                   <br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i<span class="hljs-string">+1</span>)] * [(i<span class="hljs-string">+1</span>)/(i<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n，（即第i次刚好随<br>机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i<span class="hljs-string">+1</span> （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k<span class="hljs-string">+1</span>)] * <br>[(k<span class="hljs-string">+1</span>)/(k<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。    <br></code></pre></td></tr></table></figure>
<h2 id="2021-11-22-384-打乱数组"><a href="#2021-11-22-384-打乱数组" class="headerlink" title="2021-11-22 384. 打乱数组"></a>2021-11-22 384. 打乱数组</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。<br>实现 Solution class:<br>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num) &#123;<br>        nums = num;<br>    &#125; <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ran = nums;<br>       <span class="hljs-comment">//srand(time(0)); 为什么加了这个会错呢。。。</span><br>       <span class="hljs-comment">// random_shuffle(rand.begin(),rand.end());</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ran.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(index != i) &#123;<br>            <span class="hljs-built_in">swap</span>(ran[index],ran[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ran;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
</search>
