<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4.9-力扣-780到达终点(困难)</title>
    <url>/2022/04/09/4-9-%E5%8A%9B%E6%89%A3-780%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-%E5%9B%B0%E9%9A%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。<br>从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过要求可以看出 (x,y) -&gt; (x, x + y) 或者 (x + y, y);那么可以反推得<br>(tx,ty) 的前身一定是(tx - a, ty) 或者(tx, ty - a) 其中a是上一层的tx或者ty;<br>以测试用例1来说明</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br>输入: sx = <span class="hljs-number">1</span>, sy = <span class="hljs-number">1</span>, tx = <span class="hljs-number">3</span>, ty = <span class="hljs-number">5</span><br>输出: <span class="hljs-literal">true</span><br>解释:<br>可以通过以下一系列转换从起点转换到终点：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">tx		ty<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span><br>.		.<br>.		.<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span> <span class="hljs-comment">% 3 //因为这里可以加相同的tx无数次来达到ty</span><br>.		.<br>.		.<br><span class="hljs-number">3</span> <span class="hljs-comment">% 2	2//同理 此时已经有了一边和sx 或者 sy相等，也就是从二元变成了一元，只需判断能否除余得0即可</span><br>[注]一定是大的除余小的，原因很简单......<br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reachingPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sx, <span class="hljs-keyword">int</span> sy, <span class="hljs-keyword">int</span> tx, <span class="hljs-keyword">int</span> ty)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tx &lt; sx || ty &lt; sy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (tx &gt; ty) &#123;<br>            <span class="hljs-keyword">if</span> (sy == ty)    <br>                <span class="hljs-keyword">return</span> sx &gt;= (tx % ty) &amp;&amp; (tx - sx) % sy == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx % ty, ty);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tx &lt; ty)&#123;<br>            <span class="hljs-keyword">if</span> (sx == tx)    <br>                <span class="hljs-keyword">return</span> sy &gt;= (ty % tx) &amp;&amp; (ty - sy) % sx == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx, ty % tx);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tx == sx &amp;&amp; ty == sy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2021/10/26/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="17电话号码的字母组合"><a href="#17电话号码的字母组合" class="headerlink" title="17电话号码的字母组合"></a>17电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。(九键输入法)</p>
<p>思路：九宫格每个数字（2-9）分别对应相应的字母 很显然要用哈希表将他们联系起来</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>          &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>      &#125;;<br></code></pre></td></tr></table></figure>
<p>因为是要求出所有的可能，首先想到的就是递归,回溯,dfs.代码分为两块</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> == <span class="hljs-built_in">digits</span>.<span class="hljs-built_in">size</span>()) &#123;<br>          res.push_back(tmp);<br>      &#125; //长度够了后返回结果<br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">char digit = digits[index]; <span class="hljs-regexp">//</span>输入数字的索引<br>string letters = pair[digit];<span class="hljs-regexp">//</span>输入数字对应的字母的字符串<br><span class="hljs-keyword">for</span>(auto l : letters) &#123; <span class="hljs-regexp">//</span>对每一个遍历<br>    tmp.push_back(l);<span class="hljs-regexp">//</span>tmp数组push <span class="hljs-string">&#x27;l&#x27;</span><br>    dfs(pair,index + <span class="hljs-number">1</span>,digits); <span class="hljs-regexp">//</span>递归 index++表示着要和下一个数字匹配<br>    tmp.pop_back();<span class="hljs-regexp">//</span>回溯（关键） 有点类似于树<br>&#125; <span class="hljs-regexp">//</span>处理过程<br></code></pre></td></tr></table></figure>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>            &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(pair,<span class="hljs-number">0</span>,digits);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair,<span class="hljs-keyword">int</span> index,string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">char</span> digit = digits[index];<br>        string letters = pair[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : letters) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(l);<br>            <span class="hljs-built_in">dfs</span>(pair,index + <span class="hljs-number">1</span>,digits);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22括号生成"><a href="#22括号生成" class="headerlink" title="22括号生成"></a>22括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<p>思路:有了上一个题的经验,但是这个没有什么需要处理的，直接进入dfs环节（因为只有左右括号一说）<br>还是分为两块</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(tmp.size() == n * <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.push_back</span>(tmp);<br>      &#125;<span class="hljs-comment">//因为是左右括号，每添加一次就会++ 而给的n代表的是括号对数</span><br></code></pre></td></tr></table></figure>
<p>然后又到了如何处理和回溯阶段</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">		<span class="hljs-selector-tag">if</span>(left &lt; n) &#123;<span class="hljs-comment">//首先只要左括号数小于n 一直加左括号 直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125;<br>        <span class="hljs-selector-tag">if</span>(right &lt; left) &#123;<span class="hljs-comment">//直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125; <span class="hljs-comment">//同样这两个都是用pop_back进行回溯</span><br><span class="hljs-comment">//过程大概就是 左括号三个 对应的右括号的情况 然后两个左括号在对应有括号（右括号必须小于左括号）</span><br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &lt; n) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; left) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="37解数独"><a href="#37解数独" class="headerlink" title="37解数独"></a>37解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 遵循如下规则：<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>思路：乍一看这个题是困难题,而且貌似非常复杂,其实也要遵循“标准”步骤<br>同样的道理,没有需要处理的就直接进入dfs</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//因为这个的停止条件就是遍历完全部，所以省去第一步 直接到如何处理和回溯</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-comment">//双层for找到需要判断的&quot;格子&quot;</span><br>               <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//不是空格就继续</span><br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123; <span class="hljs-comment">//假如是空格，这里有点类似第一个的 &#x27;2&#x27;代表 &quot;abc&quot; 这里的空格代表 0 - 9</span><br>                   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<span class="hljs-comment">//这里是题目的条件，要求填入的数合法,在回溯问题中可视为已知，这就可以类比为普通的dfs问题</span><br>                       board[i][j] = ch;<span class="hljs-comment">//填上相应数字</span><br>                       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//递归，如果最后返回true就说明有解</span><br>                       board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//回溯 </span><br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>判断的函数也是非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(board);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<br>                        board[i][j] = ch;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs回溯</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>edge扩展</title>
    <url>/2022/07/26/edge%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="edge不能下载扩展的解决方法"><a href="#edge不能下载扩展的解决方法" class="headerlink" title="edge不能下载扩展的解决方法"></a>edge不能下载扩展的解决方法</h2><h3 id="1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com"><a href="#1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com" class="headerlink" title="1- https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com"></a>1- <a href="https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com">https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com</a></h3><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">打开此网站，选择延迟较低<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure>
<h3 id="2-C-Windows-System32-drivers-etc"><a href="#2-C-Windows-System32-drivers-etc" class="headerlink" title="2- C:\Windows\System32\drivers\etc"></a>2- C:\Windows\System32\drivers\etc</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">找到此路径下的hosts文件，在最先面添加 <br><span class="hljs-number">116.55</span>.<span class="hljs-number">252.94</span> msedgeextensions<span class="hljs-selector-class">.sf</span><span class="hljs-selector-class">.tlu</span><span class="hljs-selector-class">.dl</span><span class="hljs-selector-class">.delivery</span><span class="hljs-selector-class">.mp</span><span class="hljs-selector-class">.microsoft</span><span class="hljs-selector-class">.com</span> #Edge商店扩展<br><span class="hljs-selector-attr">[注]</span>前面为复制的ip 后面是商店扩展的url，如果别的有问题也可以替换为别的<br></code></pre></td></tr></table></figure>
<h3 id="3-管理员身份打开cmd-输入-ipconfig-flushdns"><a href="#3-管理员身份打开cmd-输入-ipconfig-flushdns" class="headerlink" title="3- 管理员身份打开cmd 输入 ipconfig /flushdns"></a>3- 管理员身份打开cmd 输入 ipconfig /flushdns</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">客户端查询DNS的过程是：<br><br>本地host文件—本地缓存—-DNS服务器<br><br>Ｈost文件用于本地DNS解析，并且优先于寻找网络上的DNS服务器<br><br>在Windows中，它的目录通常在[Windows目录]\system32\drivers\etc\下。<br><br><span class="hljs-symbol">Hosts</span>文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/<span class="hljs-built_in">IP</span> for Windows 的标准来工作的，它的作用是包含<span class="hljs-built_in">IP</span>地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，<span class="hljs-built_in">IP</span>地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> localhost.<br><br>我们知道，当电脑访问网站时，首先通过DNS服务器把网络 域名解析成<span class="hljs-built_in">IP</span>地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回<span class="hljs-built_in">IP</span>，访问速度就会比较慢，而Hosts文件正可以解决这个 问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个<span class="hljs-built_in">IP</span>地址映射，如果没有再向DNS服 务器提出域名解析。<br><br>对于要经常访问的网站和用于测试服务，我们可以通过在Hosts中配置域名和<span class="hljs-built_in">IP</span>的映射关系，这样当我们输入域名计算机就能很快解析出<span class="hljs-built_in">IP</span>，而不用请求网络上的DNS服务器。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/11/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="第-267-场周赛-5929-处理含限制条件的好友请求"><a href="#第-267-场周赛-5929-处理含限制条件的好友请求" class="headerlink" title="第 267 场周赛 5929. 处理含限制条件的好友请求"></a>第 267 场周赛 5929. 处理含限制条件的好友请求</h2><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。<br>一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p>
<span id="more"></span>
<h2 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <span class="hljs-keyword">int</span> n;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">parent</span>(_n), <span class="hljs-built_in">size</span>(_n, <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(), parent.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<span class="hljs-comment">//给parent累加赋值 0,1,2......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">//找到x的最高树节点</span><br>        <span class="hljs-keyword">return</span> parent[x] == x ? x : parent[x] = <span class="hljs-built_in">findset</span>(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//成为朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-comment">//已经是就不用操作</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y]) &#123;并查集，维护树高，把矮的往高的合并再加上路径优化可以得到最优的复杂度<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//判断是否是朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="题目实现代码-注释"><a href="#题目实现代码-注释" class="headerlink" title="题目实现代码 + 注释"></a>题目实现代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">friendRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; re, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; qu)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt; res;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//初始化并查集类 并且赋初值n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qu.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//遍历每一个成为朋友的请求request</span><br>            <span class="hljs-keyword">int</span> x = qu[i][<span class="hljs-number">0</span>], y = qu[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// x,y分别获取值</span><br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用于判断能否成为朋友，即是否被限制（restrictions）</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">connected</span>(x, y))&#123;<span class="hljs-comment">//如果不满足这个条件说明两个人已经是朋友，就不用了进行判断，直接push_back</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; re.<span class="hljs-built_in">size</span>(); ++j)&#123;<span class="hljs-comment">//如果满足就对每一条限制(resstriction)进行判断</span><br>                    <span class="hljs-keyword">int</span> p = re[j][<span class="hljs-number">0</span>], q = re[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>((uf.<span class="hljs-built_in">connected</span>(p, x) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, y))<br>                      || (uf.<span class="hljs-built_in">connected</span>(p, y) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, x)))&#123;<span class="hljs-comment">//限制条件 P-X &amp;&amp; Q-Y则 X-Y不能成立</span><br>                        f = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果存在一种不能成立的 就让f = false 代表不能成为朋友</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)&#123; <span class="hljs-comment">//true就 unite(让两个成为朋友) push_back true;</span><br>                uf.<span class="hljs-built_in">unite</span>(x, y);<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则就 push_back false;</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>最小堆（优先队列 priority_queue）</title>
    <url>/2021/11/03/%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20priority_queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="11-03-407-接雨水-II"><a href="#11-03-407-接雨水-II" class="headerlink" title="11-03 407. 接雨水 II"></a>11-03 407. 接雨水 II</h2><p>给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的。我们可以知道容器内水的高度取决于最外层高度最低的方块，如图所示：<br><img src="/img/P1.png" alt="来自LeetCode"><br>我们假设已经知道最外层的方块接水后的高度的最小值，则此时我们根据木桶原理，肯定可以确定最小高度方块的相邻方块的接水高度。<br>我们同时更新外层的方块标记，我们在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度，如图所示:<br><img src="/img/P2.png" alt="来自LeetCode"><br>然后再次更新最外层，依次迭代直到求出所有的方块的接水高度，即可知道矩阵中的接水容量。 这里使用到了一种数据结构—最小堆</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆也叫优先队列，堆是一种特殊的完全二叉树数据结<br>堆分为两种，最大堆，最小堆。<br>最大堆：根节点大于左右两个子节点的完全二叉树<br>最小堆：根节点小于左右两个子节点的完全二叉树<br>堆可以用数组来存储，<br>a[i]处存根节点，a[2 * i]存左子树的根节点 ; a[2 * i + 1]存右子树的根节点。i从1开始!!<br><img src="/img/P3.png" alt="完全二叉树"></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++ STL实现的优先级队列是一种容器适配器，类似堆，可以随时插入元素，但只能检索到优先级队列中优先级最高的元素。<br>priority_queue&lt;int,vector,less&gt; q;最大堆（默认为最大堆）<br>priority_queue&lt;int,vector,greater&gt; q;最小堆</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; small_heap; <span class="hljs-comment">//最小堆定义方法</span><br>第一个参数T：元素（element）类型<br>第二个参数Container：必须是容器类型Container，用来存储元素（element），其类型必须是第一个参数<br>第三个参数Compare：比较形式，默认是less<br><br>q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回q里元素个数</span><br>q.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.<span class="hljs-built_in">push</span>(k);<span class="hljs-comment">//在q的末尾插入k</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure>

<h2 id="完整代码-详细注释"><a href="#完整代码-详细注释" class="headerlink" title="完整代码 + 详细注释"></a>完整代码 + 详细注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trapRainWater</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> row = heightMap.<span class="hljs-built_in">size</span>(), col = heightMap[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">3</span> || col &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//不足 3X3不可能接到水</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; minHeap;<span class="hljs-comment">//最小堆定义，</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == row - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == col - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//最外围一圈不可能接到水，先入队列</span><br>                    minHeap.<span class="hljs-built_in">push</span>(&#123;heightMap[i][j], i * col + j&#125;);<span class="hljs-comment">//i * col + j以这种方式存储</span><br>                    vis[i][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//vis数组来记录访问</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; direction =  &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向--左、上、右、下</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; tmp = minHeap.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//定义一个临时变量获取队列top()值</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">//四个方向分别遍历</span><br>                <span class="hljs-keyword">int</span> nextrow = tmp.second / col + direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> nextcol = tmp.second % col + direction[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//下一个的坐标 i，j值，承接上面的存储方法</span><br><br>            <span class="hljs-keyword">if</span>(nextrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nextrow &lt; row &amp;&amp; nextcol &gt;= <span class="hljs-number">0</span> &amp;&amp; nextcol &lt; col &amp;&amp; !vis[nextrow][nextcol]) &#123; <span class="hljs-comment">//首先得在范围内 并且未被访问</span><br>                    <span class="hljs-keyword">if</span>(heightMap[nextrow][nextcol] &lt; tmp.first) &#123; <span class="hljs-comment">//最小堆的特性，最小值，如果符合条件就说明存在“木桶” </span><br>                        res += tmp.first - heightMap[nextrow][nextcol];<span class="hljs-comment">//结果加上</span><br>                    &#125;<br>                vis[nextrow][nextcol] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//代表已经访问</span><br>                minHeap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">max</span>(heightMap[nextrow][nextcol], tmp.first), nextrow * col + nextcol&#125;);<span class="hljs-comment">//访问后放入最小堆</span><br>                &#125;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>洗牌算法-随机打乱数组</title>
    <url>/2021/11/22/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>Inside-Out Algorithm 算法的基本思路是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k）<br>这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p>
<span id="more"></span>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">RandomAccessIterator</span>&gt;                                             <br><span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">random_shuffle</span>(<span class="hljs-symbol">RandomAccessIterator</span> <span class="hljs-symbol">first, <span class="hljs-symbol">RandomAccessIterator</span></span> <span class="hljs-symbol">last</span>) &#123; <br>    <span class="hljs-keyword">if</span>(first != last)                                                             <br>        <span class="hljs-keyword">for</span>(RandomAccessIterator i = first + <span class="hljs-number">1</span>; i != last; ++i)                   <br>            iter_swap(i, first + (rand() % ((i - first) + <span class="hljs-number">1</span>)));                   <br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i<span class="hljs-string">+1</span>)] * [(i<span class="hljs-string">+1</span>)/(i<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n，（即第i次刚好随<br>机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i<span class="hljs-string">+1</span> （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k<span class="hljs-string">+1</span>)] * <br>[(k<span class="hljs-string">+1</span>)/(k<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。    <br></code></pre></td></tr></table></figure>
<h2 id="2021-11-22-384-打乱数组"><a href="#2021-11-22-384-打乱数组" class="headerlink" title="2021-11-22 384. 打乱数组"></a>2021-11-22 384. 打乱数组</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。<br>实现 Solution class:<br>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num) &#123;<br>        nums = num;<br>    &#125; <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ran = nums;<br>       <span class="hljs-comment">//srand(time(0)); 为什么加了这个会错呢。。。</span><br>       <span class="hljs-comment">// random_shuffle(rand.begin(),rand.end());</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ran.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(index != i) &#123;<br>            <span class="hljs-built_in">swap</span>(ran[index],ran[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ran;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2488</title>
    <url>/2023/03/06/POJ-2488/</url>
    <content><![CDATA[<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">35</span>;<br><span class="hljs-keyword">int</span> vis[N][N];<br><span class="hljs-keyword">int</span> p, q ,flag;<br><span class="hljs-keyword">char</span> res[<span class="hljs-number">1000</span>];<br><span class="hljs-comment">//要求字典序 所以</span><br><span class="hljs-comment">//     A B C</span><br><span class="hljs-comment">//   1 。。。       优先-y 让字母更靠近A</span><br><span class="hljs-comment">//   2 。。。       其次-x 让数字更靠近1</span><br><span class="hljs-comment">//   3 。。。</span><br><br><span class="hljs-comment">//Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. </span><br><span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br>    <span class="hljs-comment">//最终状态 走遍所有格子</span><br>    <span class="hljs-keyword">if</span> (cnt == p * q) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A1&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">2</span> * cnt; i++) &#123;<br>            cout &lt;&lt; res[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>        flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//此处改变</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> &amp;&amp; !flag; i++) &#123;<br>        <span class="hljs-keyword">int</span> tx = x + dir[i][<span class="hljs-number">0</span>], ty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//不在范围内</span><br>        <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">1</span> || tx &gt; p || ty &lt; <span class="hljs-number">1</span> || ty &gt; q) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//没访问过</span><br>        <span class="hljs-keyword">if</span> (!vis[tx][ty]) &#123;<br>            vis[tx][ty] = <span class="hljs-number">1</span>;<br>            res[<span class="hljs-number">2</span> * cnt] = <span class="hljs-string">&#x27;A&#x27;</span> + ty - <span class="hljs-number">1</span>;<br>            res[<span class="hljs-number">2</span> * cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span> + tx - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(tx, ty, cnt + <span class="hljs-number">1</span>);<br>            vis[tx][ty] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t, ca = <span class="hljs-number">0</span>;<span class="hljs-comment">//输入次数 ， 结果的序号</span><br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; p &gt;&gt; q;<span class="hljs-comment">// row col</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Scenario #i&quot;</span> &lt;&lt; ++ca &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<span class="hljs-comment">//给vis赋值为0</span><br>        flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前状态，dfs会改变flag，如果没改变说明没有找到结果</span><br>        vis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始第一个点为已经经过 </span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#1:</span><br><span class="hljs-built_in">A1</span><br><br><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#2:</span><br>impossible<br><br><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#3:</span><br>A<span class="hljs-symbol">1B</span>3C1A<span class="hljs-symbol">2B</span>4C2A<span class="hljs-symbol">3B</span>1C3A<span class="hljs-symbol">4B</span>2C4<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-2488"><a href="#http-poj-org-problem-id-2488" class="headerlink" title="http://poj.org/problem?id=2488"></a><a href="http://poj.org/problem?id=2488">http://poj.org/problem?id=2488</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3009</title>
    <url>/2023/03/08/POJ-3009/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.可以往任意方向走 但是不碰到障碍物不会停下<br>2.碰到障碍物（石头）就会把石头撞碎 -&gt; 从1变成0<br>3.默认规定 终点位置摩擦力极大 即到终点就会停。</p>
<span id="more"></span>
<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">#<span class="hljs-keyword">include</span>&lt;iostream&gt;<br>using namespace std;<br><br>int square[30][30];<br>int min_steps;<br>int w, <span class="hljs-keyword">h</span>;<br>int sx, sy;<br>int <span class="hljs-keyword">dir</span>[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;;<br>void dfs(int x, int y, int cnt) &#123;<br>    <span class="hljs-comment">//You cannot throw the stone more than 10 times in a game.If the stone does not reach the goal in 10 moves, the game ends in failure.</span><br>    <span class="hljs-keyword">if</span> (cnt &gt;= 10) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (int i = 0; i &lt; 4; i++) &#123;<br>        int tx = x + <span class="hljs-keyword">dir</span>[i][0];<br>        int <span class="hljs-keyword">ty</span> = y + <span class="hljs-keyword">dir</span>[i][1];<br>        int flag = 1, tag = 0;<br>        <span class="hljs-comment">//Once the stone begins to move, it will proceed until it hits a block.</span><br>        <span class="hljs-keyword">while</span> (1) &#123;<br>            <span class="hljs-comment">//越界</span><br>            <span class="hljs-keyword">if</span> (tx &lt; 1 || tx &gt; <span class="hljs-keyword">h</span> || <span class="hljs-keyword">ty</span> &lt; 1 || <span class="hljs-keyword">ty</span> &gt; w) &#123;<br>                flag = 0;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//碰到石头</span><br>            <span class="hljs-keyword">if</span> (square[tx][<span class="hljs-keyword">ty</span>] == 1) &#123;<br>                tag = 1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//到达终点</span><br>            <span class="hljs-keyword">if</span> (square[tx][<span class="hljs-keyword">ty</span>] == 3 &amp;&amp; min_steps &gt; ++cnt) &#123;<br>                min_steps = cnt;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//一直移动</span><br>            tx += <span class="hljs-keyword">dir</span>[i][0];<br>            <span class="hljs-keyword">ty</span> += <span class="hljs-keyword">dir</span>[i][1];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//越界则换方向</span><br>        <span class="hljs-keyword">if</span> (tag) &#123;<br>            square[tx][<span class="hljs-keyword">ty</span>] = 0;<br>            <span class="hljs-comment">//You may throw it to any direction unless it is blocked immediately</span><br>            tx -= <span class="hljs-keyword">dir</span>[i][0];<br>            <span class="hljs-keyword">ty</span> -= <span class="hljs-keyword">dir</span>[i][1];<br>            <span class="hljs-keyword">if</span> (tx == x &amp;&amp; <span class="hljs-keyword">ty</span> == y) &#123;<br>                square[tx + <span class="hljs-keyword">dir</span>[i][0]][<span class="hljs-keyword">ty</span> + <span class="hljs-keyword">dir</span>[i][1]] = 1;<br>            &#125;<br><br>            dfs(tx, <span class="hljs-keyword">ty</span>, cnt + 1);<br>            square[tx + <span class="hljs-keyword">dir</span>[i][0]][<span class="hljs-keyword">ty</span> + <span class="hljs-keyword">dir</span>[i][1]] = 1;<br>        &#125;<br><br>    &#125;<br>&#125;<br>int main() &#123;<br>    min_steps = INT_MAX;<span class="hljs-comment">//记录结果</span><br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; <span class="hljs-keyword">h</span> &amp;&amp; (w + <span class="hljs-keyword">h</span>)) &#123;<br>        <span class="hljs-keyword">for</span> (int i = 1; i &lt;= w; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = 1; j &lt;= <span class="hljs-keyword">h</span>; j++) &#123;<br>                cin &gt;&gt; square[i][j];<br>                <span class="hljs-keyword">if</span> (square[i][j] == 2) &#123;<br>                    sx = i;<br>                    sy = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        dfs(sx, sy, 0);<br>        min_steps &lt;= 10 ? cout &lt;&lt; min_steps : cout &lt;&lt; &#x27;-1&#x27;;<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff">1<br>4<br><span class="hljs-deletion">-1</span><br>4<br>10<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3009"><a href="#http-poj-org-problem-id-3009" class="headerlink" title="http://poj.org/problem?id=3009"></a><a href="http://poj.org/problem?id=3009">http://poj.org/problem?id=3009</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-1321</title>
    <url>/2023/03/09/POJ-1321/</url>
    <content><![CDATA[<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">int</span> n, k;<br><span class="hljs-keyword">char</span> b[N][N];<br><span class="hljs-keyword">bool</span> visr[N], visc[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(visr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visr));<br>    <span class="hljs-built_in">memset</span>(visc, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visc));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == k) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (b[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !visc[j] &amp;&amp; !visr[i]) &#123;<br>                visr[i] = visc[j] = <span class="hljs-number">1</span>;<br>                res += <span class="hljs-built_in">dfs</span>(j + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>);<br>                visr[i] = visc[j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k &amp;&amp;  n != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                cin &gt;&gt; b[i][j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">2 1<br><span class="hljs-comment">#.</span><br>.<span class="hljs-comment">#</span><br>4 4<br><span class="hljs-string">...</span><span class="hljs-comment">#</span><br><span class="hljs-string">..</span><span class="hljs-comment">#.</span><br>.<span class="hljs-comment">#..</span><br><span class="hljs-comment">#...</span><br>-1 -1<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-1321"><a href="#http-poj-org-problem-id-1321" class="headerlink" title="http://poj.org/problem?id=1321"></a><a href="http://poj.org/problem?id=1321">http://poj.org/problem?id=1321</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3278</title>
    <url>/2023/03/10/POJ-3278/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.找最短路径 一般用bfs<br>2.三种状态 +1 -1 *2</p>
<span id="more"></span>
<h3 id="代码-注释（应该无需）"><a href="#代码-注释（应该无需）" class="headerlink" title="代码 + 注释（应该无需）"></a>代码 + 注释（应该无需）</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">MAXN</span> = <span class="hljs-number">10000</span>;<br>bool vis[<span class="hljs-symbol">MAXN</span>];<br>int que[<span class="hljs-symbol">MAXN</span>][<span class="hljs-number">2</span>];<br>int front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br>int <span class="hljs-symbol">N</span>, <span class="hljs-symbol">K</span>;<br>void bfs() &#123;<br>    while (rear &lt; front) &#123;<br>        int x = que[rear][<span class="hljs-number">0</span>], t = que[rear++][<span class="hljs-number">1</span>];<br>        if (x == <span class="hljs-symbol">K</span>) &#123;<br>            cout &lt;&lt; t &lt;&lt; endl;<br>            return;<br>        &#125;<br>        if (x + <span class="hljs-number">1</span> &lt;= <span class="hljs-symbol">MAXN</span> &amp;&amp; !vis[x + <span class="hljs-number">1</span>]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = x + <span class="hljs-number">1</span>;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[x + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        if (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !vis[x - <span class="hljs-number">1</span>]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = x - <span class="hljs-number">1</span>;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[x - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        if (<span class="hljs-number">2</span> * x &lt;= <span class="hljs-symbol">MAXN</span> &amp;&amp; !vis[<span class="hljs-number">2</span> * x]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> * x;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[<span class="hljs-number">2</span> * x] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br>int main() &#123;<br>    cin &gt;&gt; <span class="hljs-symbol">N</span> &gt;&gt; <span class="hljs-symbol">K</span>;<br>    que[front][<span class="hljs-number">0</span>] = <span class="hljs-symbol">N</span>; que[front++][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    vis[<span class="hljs-symbol">N</span>] = <span class="hljs-number">1</span>;<br>    bfs();<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">17</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3278"><a href="#http-poj-org-problem-id-3278" class="headerlink" title="http://poj.org/problem?id=3278"></a><a href="http://poj.org/problem?id=3278">http://poj.org/problem?id=3278</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3126</title>
    <url>/2023/03/13/POJ-3126/</url>
    <content><![CDATA[<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>1.首先需要判断素数，而每次判断很耗时间，所以使用素数筛打表,此处使用欧拉筛<br>2.找最短路径则一般使用bfs</p>
<span id="more"></span>
<p>欧拉筛</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">int prime<span class="hljs-comment">[10005]</span>;<br>bool isprime<span class="hljs-comment">[10005]</span>;<br>void getPrime() &#123;<br>    for (int i = 0; i &lt;= 10000; i++) &#123;<br>        isprime<span class="hljs-comment">[i]</span> = 1;<br>    &#125;<br>    for (int i = 2; i &lt;= 10000; i++) &#123;<br>        if (isprime<span class="hljs-comment">[i]</span>) &#123;<br>            prime<span class="hljs-comment">[cnt++]</span> = i;<br>        &#125;<br>        for (int j = 1; j &lt; cnt &amp;&amp; i * prime<span class="hljs-comment">[j]</span> &lt;= 10000; j++) &#123;<br>            isprime<span class="hljs-comment">[prime<span class="hljs-comment">[j]</span> * i]</span> = 0;<br>            if (i % prime<span class="hljs-comment">[j]</span> == 0) break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">bool</span> isprime[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">int</span> vis[<span class="hljs-number">10000</span>];<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">state</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    string s;<br>    <span class="hljs-keyword">int</span> step;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>        isprime[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isprime[i]) &#123;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt;= <span class="hljs-number">10000</span>; j++) &#123;<br>            isprime[prime[j] * i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">s_to_int</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        res = res * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    queue&lt;state&gt; q;<br>    state st;<br>    st.s = s; st.step = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(st);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        state tmp = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">compare</span>(tmp.s) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> tmp.step;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                state t = tmp;<br>                t.step++;<br>                t.s[i] = j + <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>                <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">s_to_int</span>(t.s);<br>                <span class="hljs-keyword">if</span> (!vis[num] &amp;&amp; isprime[num] == <span class="hljs-number">1</span>) &#123;<br>                    vis[num] = <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(t);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">getPrime</span>();<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>        string s, t;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">bfs</span>(s, t);<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1033 </span><span class="hljs-number">8179</span><br><span class="hljs-symbol">1373 </span><span class="hljs-number">8017</span><br><span class="hljs-symbol">1033 </span><span class="hljs-number">1033</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">6<br>7<br>0<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3126"><a href="#http-poj-org-problem-id-3126" class="headerlink" title="http://poj.org/problem?id=3126"></a><a href="http://poj.org/problem?id=3126">http://poj.org/problem?id=3126</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3414</title>
    <url>/2023/03/14/POJ-3414/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.给出两个瓶子的容量（a,b）和一个目标容量(c) 有三种操作<br>FILL(i)        fill the pot i (1 ≤ i ≤ 2) from the tap;<br>DROP(i)      empty the pot i to the drain;<br>POUR(i,j)    pour from pot i to pot j; after this operation either the pot j is full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j)<br>2. 标记状态 有六种转化 F1,F2,D1,D2,P12,P21</p>
<span id="more"></span>
<h2 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> prior[N * N], res[N * N];<span class="hljs-comment">//记录前一个的操作</span><br><span class="hljs-keyword">int</span> vis[N][N];<br><span class="hljs-keyword">int</span> a, b, c;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a, b, cur, step;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(a), <span class="hljs-built_in">b</span>(b), <span class="hljs-built_in">cur</span>(c), <span class="hljs-built_in">step</span>(s) &#123;&#125;;<br>&#125;;<br>queue&lt;node&gt; q;<br><br><span class="hljs-comment">//输出路径 </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prior[cur] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">solve</span>(prior[cur]);<br>    <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;DROP(1)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FILL(1)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;POUR(1,2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">4</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;DROP(2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">5</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FILL(2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">6</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;POUR(2,1)&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    prior[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>());<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        node t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (t.a == c || t.b == c) &#123;<br>            cout &lt;&lt; t.step &lt;&lt; endl;<br>            <span class="hljs-built_in">solve</span>(t.cur);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//6种状态</span><br>        <span class="hljs-keyword">int</span> sum = t.a + t.b;<br>        <span class="hljs-keyword">if</span> (t.a) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[<span class="hljs-number">0</span>][t.b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, t.b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur; vis[<span class="hljs-number">0</span>][t.b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mb = b - t.b;<br>            <span class="hljs-keyword">if</span> (t.a &lt; mb &amp;&amp; !vis[<span class="hljs-number">0</span>][sum]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, sum, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.a &gt;= mb &amp;&amp; !vis[t.a - mb][b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a - mb, b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a - mb][b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.a != a &amp;&amp; !vis[a][t.b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(a, t.b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[a][t.b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t.b) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[t.a][<span class="hljs-number">0</span>]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a, <span class="hljs-number">0</span>, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">4</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> ma = a - t.a;<br>            <span class="hljs-keyword">if</span> (t.b &lt; ma &amp;&amp; !vis[sum][<span class="hljs-number">0</span>]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(sum, <span class="hljs-number">0</span>, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[sum][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">6</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.b &gt;= ma &amp;&amp; !vis[a][t.b - ma]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(a, t.b - ma, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[a][t.b - ma] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">6</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.b != b &amp;&amp; !vis[t.a][b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a, b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a][b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">5</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">bfs</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/10/14/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="逻辑位运算符"><a href="#逻辑位运算符" class="headerlink" title="逻辑位运算符"></a>逻辑位运算符</h3><p>&amp; - 位与 100 | 101 = 100<br>| - 位或 100 | 101 = 101<br>^ - 异或 100 | 101 = 001<br>~ - 按位取反  100 = 011</p>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p><code>左移</code>  100 &lt;&lt; 1 = 1000<br><code>右移</code>  100 &gt;&gt; 1 = 10</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="2的幂（简单）"><a href="#2的幂（简单）" class="headerlink" title="2的幂（简单）"></a>2的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-two/">https://leetcode.cn/problems/power-of-two/</a></p>
<p>如果一个数n是2的幂，那么二进制下的样子应该是 10,100,1000……<br>那么n - 1就是 01 011 0111，此时对 n 和 n - 1进行 <code>&amp;</code> 操作<br>按照规则，得到的是 00,000,0000,所以只需要判断 (n &amp; (n - 1))等于0即可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfTwo(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4的幂（简单）"><a href="#4的幂（简单）" class="headerlink" title="4的幂（简单）"></a>4的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-four/">https://leetcode.cn/problems/power-of-four/</a></p>
<p>如果n是4的幂,就代表 4^x == n –&gt;  2^2x == n<br>所以4的幂一定是2的幂，但是2的幂不一定是4的幂，如2^(2x + 1);<br>那么为了区分 2^2x 和 2^(2x + 1),则可以用 mod 3,前者会等于1,后者等于2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfFour(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (n % <span class="hljs-number">3</span>) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><p><a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>如 1011<br>1、 每次&amp;1 然后 右移<br>2、 n = 1011  n - 1 = 1010 所以 n &amp; (n - 1) = 1010 即消去了最后的1,只需重复这个操作</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 方法2</span><br>    <span class="hljs-built_in">int</span> hammingWeight(<span class="hljs-built_in">uint</span>32_t n) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交换数字（中等）"><a href="#交换数字（中等）" class="headerlink" title="交换数字（中等）"></a>交换数字（中等）</h3><p><a href="https://leetcode.cn/problems/swap-numbers-lcci/">https://leetcode.cn/problems/swap-numbers-lcci/</a></p>
<p>要求交换 a, b 且不用临时变量，我懂了，那我直接调函数！<br>漏~ 异或<code>^</code>运算登场<br>    异或的基本操作 a ^ a = 0<br>                   a ^ 0 = a<br>                   a ^ b = b ^ a<br>只需三步：<br>    a = a ^ b; // a = a ^ b<br>    b = a ^ b; // b = (a) ^ b = (展开)(a ^ b) ^ b = a,此时 b = a了<br>    a = a ^ b; // a = (a) ^ (b) = a ^ b ^ a = b；<br>很抽象，但是你细品。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) &#123;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[1]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        return numbers;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字（简单）"><a href="#只出现一次的数字（简单）" class="headerlink" title="只出现一次的数字（简单）"></a>只出现一次的数字（简单）</h3><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<p>异或<code>^</code> : 我又来喽~<br>    基本操作之 – a ^ a = 0<br>直接所有的都异或一遍, 最后得到的就是结果(因为所有的couple都被消了, 独留单身狗)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-II-（中等）"><a href="#只出现一次的数字-II-（中等）" class="headerlink" title="只出现一次的数字 II （中等）"></a>只出现一次的数字 II （中等）</h3><p><a href="https://leetcode.cn/problems/single-number-ii/">https://leetcode.cn/problems/single-number-ii/</a></p>
<p>稍微修改一下, 所有的couple都变成三人行了。不对劲,不对劲,不对劲。<br>没办法异或了, 每个数都是int型, 也就是32位, 那就对所有数的每一位单独处理<br>看一下所有数在某一位上的1的个数<br>                3个 : 代表他们三个是出现了3次的, 单独的那个在这一位上没有信息(1)<br>                4个 ：说明单独的那个在这一位有信息<br>很合理！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>                cnt += (n &gt;&gt; i) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 获取所有数在第i位上1的总数</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">3</span>) &#123;<br>			<span class="hljs-comment">// 1 &lt;&lt; i是左移运算符, 就是把1往左移动i位</span><br>			<span class="hljs-comment">// 1 &lt;&lt; 2 = 100,然后在用 res 进行 | 操作, 就会把res的第i位 变成1</span><br>                res |= (<span class="hljs-number">1</span> &lt;&lt; i); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-III（中等）"><a href="#只出现一次的数字-III（中等）" class="headerlink" title="只出现一次的数字 III（中等）"></a>只出现一次的数字 III（中等）</h3><p><a href="https://leetcode.cn/problems/single-number-iii/">https://leetcode.cn/problems/single-number-iii/</a></p>
<p>这个也能出到3,真的是 无 语 死 啦~~(小潮音)<br>简单来说, 又回到了couple状态, 不过这次是两个单身狗了<br>一遍异或下来的结果是: 狗1 ^ 狗2, 怎么能分开呢？<br>        异或小提示：<br>            a ^ b = 0对于这个题是不可能的, 如果 = 0 他俩就是couple了<br>            a ^ b 的结果中肯定有一位是 1 且 a 和 b 在这一位上还不一样(异或某一位一样的话是 = 0)<br>就用这个把他们区分开来，开码！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		<span class="hljs-comment">// num是所有异或后的结果</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>            num ^= n;<br>        &#125;<br>		<span class="hljs-comment">// dif是最后一个1 如 1010  --&gt;  10</span><br>		<span class="hljs-comment">// 还要确保溢出问题</span><br>        <span class="hljs-keyword">int</span> dif = (num == INT_MIN ? num : num &amp; (-num));<br>        <span class="hljs-keyword">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>			<span class="hljs-comment">// 根据这一位来区分</span><br>            <span class="hljs-keyword">if</span> (n &amp; dif) &#123;<br>                res1 ^= n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res2 ^= n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;res1, res2&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>吐槽一下： 要不是题目要求 <code>必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</code> 我是真想用哈希表啊,我差那点空间吗！！！</p>
<h3 id="汉明距离（简单）"><a href="#汉明距离（简单）" class="headerlink" title="汉明距离（简单）"></a>汉明距离（简单）</h3><p><a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p>
<p>来个简单题休息一下,就是异或然后看1的个数。</p>
<p>复习：<br>    异或 : 相同为0,不同是1<br>    与 : n &amp; (n - 1) 很常用, 消除最后一位1</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-built_in">int</span> hammingDistance(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = x ^ y;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">num</span>) &#123;<br>            <span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span> &amp; (<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交替位二进制数（简单）"><a href="#交替位二进制数（简单）" class="headerlink" title="交替位二进制数（简单）"></a>交替位二进制数（简单）</h3><p><a href="https://leetcode.cn/problems/binary-number-with-alternating-bits/">https://leetcode.cn/problems/binary-number-with-alternating-bits/</a></p>
<p>先转换成二进制,然后挨着判断相邻的一不一样，歪瑞EZ啊</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> hasAlternatingBits(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span> || (n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>位运算</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/10/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">动态规划是一种解决复杂问题的优化技术，它通过将问题分解为子问题并以自底向上的方式求解，最终得到整体问题的最优解。动态规划的核心思想是通过存储和复用之前计算过的结果，避免重复计算以提高效率。<br><br>动态规划的解决过程通常包括以下几个步骤：<br><br>1.确定状态：将原问题拆解成若干子问题，通过定义合适的状态来描述子问题。<br><br>2.定义状态转移方程：根据子问题之间的关系，建立状态转移方程，用于描述问题的最优解与子问题的关系。<br><br>3.定义初始条件：确定最简单的子问题的解，作为初始条件或边界条件。<br><br>4.计算顺序：确定计算子问题的顺序，通常采用自底向上的方式。<br><br>5.储存中间结果：使用数组或其他数据结构来存储中间计算结果，以提高效率。<br><br>6.求解目标问题：根据状态转移方程和初始条件计算出最优解，即整体问题的解。<br><br>动态规划常用于求解具有重叠子问题特性的问题，即原问题的解可以通过子问题的解来计算。它适用于很多领域，例如图论、计算机视觉、自然语言处理等，可以解决一些经典的问题，例如最短路径、背包问题、序列比对等。动态规划能够有效地优化时间复杂度，提供高效的解决方案。<br></code></pre></td></tr></table></figure>

<h2 id="斐波那契类型"><a href="#斐波那契类型" class="headerlink" title="斐波那契类型"></a>斐波那契类型</h2><h3 id="爬楼梯、斐波那契数、第-N-个泰波那契数（简单）"><a href="#爬楼梯、斐波那契数、第-N-个泰波那契数（简单）" class="headerlink" title="爬楼梯、斐波那契数、第 N 个泰波那契数（简单）"></a>爬楼梯、斐波那契数、第 N 个泰波那契数（简单）</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a><br><a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a><br><a href="https://leetcode.cn/problems/n-th-tribonacci-number/">https://leetcode.cn/problems/n-th-tribonacci-number/</a></p>
<p>三个基本差不多的题，贴一个 <code>斐波那契数</code> 的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="使用最小花费爬楼梯（简单）"><a href="#使用最小花费爬楼梯（简单）" class="headerlink" title="使用最小花费爬楼梯（简单）"></a>使用最小花费爬楼梯（简单）</h3><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p><code>状态转移方程</code>: dp[n] = min(dp[n - 1] + cost[n - 1], dp[n - 2] + cost[n - 2])<br><code>初始值设置</code>: dp[0] = 0, dp[1] = 0;<br><code>解释</code>： 可以走1步或2步, 所以从 n 往前推，要么等于 n - 1 的状态加上 n - 1 的 cost, 要么等于 n - 2 的状态加上 n - 2 的 cost</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="打家劫舍（中等）"><a href="#打家劫舍（中等）" class="headerlink" title="打家劫舍（中等）"></a>打家劫舍（中等）</h3><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
<p><code>状态转移方程 </code> dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);<br><code>初始状态 </code> dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);<br><code>解释 </code> dp[i]代表前i户的最大值。 因为不能选挨着的，所以对于 n 要么选择 n - 2 加上 当前位置的值（即偷当前这户，且保证挨着的前一个没被偷）或 n - 1 （不偷当前这户则等于前一个状态）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="删除并获得点数-（中等）"><a href="#删除并获得点数-（中等）" class="headerlink" title="删除并获得点数 （中等）"></a>删除并获得点数 （中等）</h3><p><a href="https://leetcode.cn/problems/delete-and-earn/description/">https://leetcode.cn/problems/delete-and-earn/description/</a></p>
<p>这个题可以转化成 <code>打家劫舍</code> 同样的道理是选了某一个就不能选它相邻的, 所以想办法把这个题变成打家劫舍<br>方法: 把所有数总和(如 1 2 3 3 3) 记录一下 (1 2 9) 没出现的记作 0, 此时就变成了 <code>打家劫舍</code>。 这里可以优化一下 不用记录数据范围 1 -&gt; 1e4 所有的数, 遍历一遍求出最大值即可</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 直接套用打家劫舍的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; maxVal) &#123;<br>                maxVal = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cnt[num] += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(cnt);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="不同路径（中等）"><a href="#不同路径（中等）" class="headerlink" title="不同路径（中等）"></a>不同路径（中等）</h3><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a><br>不知道为啥挂了个中等 应该属于简单题</p>
<p><code>状态转移方程 </code>  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br><code>初始状态 </code> dp[0][n] = 1, dp[m][0] = 1; 起点的同一行或列的路径数肯定是1<br><code>解释 </code> dp[i][j]是结果。 对于每一个(i, j) 只能从 (i - 1, j) | (i, j - 1) 这两个地方到达所以直接相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt; (n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="不同路径-II（中等）"><a href="#不同路径-II（中等）" class="headerlink" title="不同路径 II（中等）"></a>不同路径 II（中等）</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/">https://leetcode.cn/problems/unique-paths-ii/</a></p>
<p>相比于 I 只是增加了障碍物, 只需要初始化的时候第一行和第一列只要碰到障碍物，其之后的都设置为 0<br>这里有个小坑！(0, 0)这个起点是可能会有障碍物的 这种情况直接返回 0</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最小路径和（中等）"><a href="#最小路径和（中等）" class="headerlink" title="最小路径和（中等）"></a>最小路径和（中等）</h3><p><a href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
<p><code>状态转移方程 </code>  dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];<br><code>初始状态 </code> 算一下第一行第一列的前缀和<br><code>解释 </code> 略，跟前一个类似</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;<br>        int m = grid.size(), n = grid<span class="hljs-comment">[0]</span>.size();<br>        if (n == 0 || n == 0) &#123;<br>            return 0;<br>        &#125;<br>        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>;<br>        &#125;<br>        for (int j = 1; j &lt; n; j++) &#123;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j - 1]</span> + grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = min(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>) + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>膜拜灵神</title>
    <url>/2023/11/02/code%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://www.bilibili.com/video/BV1Ks41127DU/?spm_id_from=333.999.0.0">【指弹】松井佑贵Yuki Matsui改编 - 那些年</a>  </p>
<p><code>2023/11/02</code> </p>
<p>灵神题目链接:<a href="https://huxulm.github.io/lc-rating/#/zen">https://huxulm.github.io/lc-rating/#/zen</a></p>
<h2 id="2023-11-02"><a href="#2023-11-02" class="headerlink" title="2023/11/02"></a>2023/11/02</h2><h3 id="【每日打卡】2103-环和杆-简单-–-1258"><a href="#【每日打卡】2103-环和杆-简单-–-1258" class="headerlink" title="【每日打卡】2103. 环和杆 (简单 – 1258)"></a>【每日打卡】2103. 环和杆 (简单 – 1258)</h3><p><a href="https://leetcode.cn/problems/rings-and-rods/">https://leetcode.cn/problems/rings-and-rods/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPoints</span><span class="hljs-params">(string rings)</span> </span>&#123;<br>        vector&lt;unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">cnt</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rings.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">int</span> num = rings[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">char</span> color = rings[i];<br>            cnt[num][color]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[i][<span class="hljs-string">&#x27;R&#x27;</span>] &amp;&amp; cnt[i][<span class="hljs-string">&#x27;G&#x27;</span>] &amp;&amp; cnt[i][<span class="hljs-string">&#x27;B&#x27;</span>]) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词-中等"><a href="#438-找到字符串中所有字母异位词-中等" class="headerlink" title="438. 找到字符串中所有字母异位词 (中等)"></a>438. 找到字符串中所有字母异位词 (中等)</h3><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string">https://leetcode.cn/problems/find-all-anagrams-in-a-string</a></p>
<p>核心思路是 <code>滑动窗口</code><br>第一次提交使用了两个哈希表,一个固定不变，另一个用来存储 <code>滑动</code> 后的结果 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">//判断不合理直接返回</span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pLetters</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sLetters</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>		<span class="hljs-comment">// pLetters代表字符串p的状态</span><br>		<span class="hljs-comment">// sLetters暂时存入和字符串p相同长度的子串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            pLetters[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sLetters[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>		<span class="hljs-comment">// 先判断一下, 如果直接匹配要加入到结果，因为后续会直接滑动，把这个给漏掉</span><br>        <span class="hljs-keyword">if</span> (pLetters == sLetters) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>		<span class="hljs-comment">// 窗口开始向右滑动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - p.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sLetters[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--; <span class="hljs-comment">// 去除left的字符</span><br>            sLetters[s[i + p.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;a&#x27;</span>]++; <span class="hljs-comment">// 加上right的字符</span><br><br>            <span class="hljs-keyword">if</span> (pLetters == sLetters) &#123; <span class="hljs-comment">// 符合条件加入到结果</span><br>                res.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>第二次提交是对第一次的优化， 可以省去一个哈希表的空间，用一个 <code>diff</code> 来代替。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; p.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>		<span class="hljs-comment">// 此处count代表的是差异，只要不等于0就代表有差异</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">size</span>(); i++) &#123;<br>			<span class="hljs-comment">// 一边加 一边减 如果匹配的话 count里所有元素都应该是0</span><br>            count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++; <br>            count[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;;<br>        &#125;<br><br>		<span class="hljs-comment">// 用一个int型的 diff 来记录当前是否有差异</span><br>        <span class="hljs-keyword">int</span> diff = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (count[i] != <span class="hljs-number">0</span>) &#123;<br>                diff++;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">// 还是要先把第一个窗口提前判断</span><br>        <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - p.<span class="hljs-built_in">size</span>(); i++) &#123;<br>			<span class="hljs-comment">// 此时窗口向右滑, left侧的字符会移出窗口,所以会导致 count中 -1</span><br>			<span class="hljs-comment">// 那么如果此时count == 1 代表 s是比p在这个字符上多一个， 现在把left移出后 -&gt; 就平衡了，也就是diff--</span><br>            <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) &#123;<br>                diff--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                diff++;<br>            &#125;<br>            count[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>			<span class="hljs-comment">// 右侧同理</span><br>            <span class="hljs-keyword">if</span> (count[s[i + p.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">-1</span>) &#123;<br>                diff--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count[s[i + p.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span>) &#123;<br>                diff++;<br>            &#125;<br>            count[s[i + p.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">0</span>) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="30-串联所有单词的子串-（困难）"><a href="#30-串联所有单词的子串-（困难）" class="headerlink" title="30. 串联所有单词的子串 （困难）"></a>30. 串联所有单词的子串 （困难）</h3><p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words">https://leetcode.cn/problems/substring-with-concatenation-of-all-words</a><br>这个题是上一个题的进阶版，就是把字符换成字符串，来进行匹配，思路还是滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string &amp;s, vector&lt;string&gt; &amp;words)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> m = words.<span class="hljs-built_in">size</span>(), n = words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>		<span class="hljs-comment">// 范围是从 0 到 n, 从n + 1位置开始的操作就已经在（0，n）这个范围内的遍历下进行过了。</span><br>		<span class="hljs-comment">// i + m * n &lt;= s.size()是判断不越界</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; i + m * n &lt;= s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>			<span class="hljs-comment">// 这里的differ要用哈希表，因为要存字符串和它对应的差异数</span><br>            unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; differ;<br>			<span class="hljs-comment">// 先把s串的第一个窗口的都加进来</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                differ[s.<span class="hljs-built_in">substr</span>(i + j * n, n)]++;<br>            &#125;<br>			<span class="hljs-comment">// 遍历words(p)然后减一下差异，如果减完=0，就代表这个字符串是没有差异的，在这里要erase删除一下，因为后续判断需要。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> w : words) &#123;<br>                <span class="hljs-keyword">if</span> (--differ[w] == <span class="hljs-number">0</span>) &#123;<br>                    differ.<span class="hljs-built_in">erase</span>(w);<br>                &#125;<br>            &#125;<br><br>			<span class="hljs-comment">// 窗口移动, 从 i 往后一次 +n, 也就是一次加一个字符串的长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> start = i; start &lt; s.<span class="hljs-built_in">size</span>() - m * n + <span class="hljs-number">1</span>; start += n) &#123;<br>                <span class="hljs-keyword">if</span> (start != i) &#123;<br>					<span class="hljs-comment">// 下面的操作就熟悉了,就是把左侧的移出，右侧的加进来</span><br>                    string word = s.<span class="hljs-built_in">substr</span>(start + (m - <span class="hljs-number">1</span>) * n, n);<br>                    <span class="hljs-keyword">if</span> (++differ[word] == <span class="hljs-number">0</span>) &#123;<br>                        differ.<span class="hljs-built_in">erase</span>(word);<br>                    &#125;<br>                    word = s.<span class="hljs-built_in">substr</span>(start - n, n);<br>                    <span class="hljs-keyword">if</span> (--differ[word] == <span class="hljs-number">0</span>) &#123;<br>                        differ.<span class="hljs-built_in">erase</span>(word);<br>                    &#125;<br>                &#125;<br>				<span class="hljs-comment">// 对应了上面的erase操作, 因为要用empty()函数</span><br>                <span class="hljs-keyword">if</span> (differ.<span class="hljs-built_in">empty</span>()) &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(start);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="76-最小覆盖子串-（困难）"><a href="#76-最小覆盖子串-（困难）" class="headerlink" title="76. 最小覆盖子串 （困难）"></a>76. 最小覆盖子串 （困难）</h3><p><a href="https://leetcode.cn/problems/minimum-window-substring">https://leetcode.cn/problems/minimum-window-substring</a><br>我觉得算中等+, 依然 <code>滑动窗口</code></p>
<p>这个题可以不用两个哈希表，而只用一个哈希表，思路是用一个cnt来计算<br>t 中的各个字符在滑动过程中的 <code>差值</code>，只要差值都小于0就说明当前窗口里的s的子串是涵盖了t子串的所有字符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>		<span class="hljs-comment">// 先判断合不合理 --&gt; 在此处吃亏一个提交</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; t.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; Cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>			<span class="hljs-comment">// t串的++, s串(窗口)的--，对应了 “差值都小于0”这个思路</span><br>            Cnt[t[i]]++;<br>            Cnt[s[i]]--;<br>        &#125;<br>		<span class="hljs-comment">// “只要差值都小于0” 对这个的实现</span><br>        function&lt;<span class="hljs-built_in"><span class="hljs-keyword">bool</span></span>()&gt; check = [&amp;] () &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : Cnt) &#123;<br>                <span class="hljs-keyword">if</span> (it.second &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>		<span class="hljs-comment">// 也是要先把第一个窗口的判断一下 --&gt; 在此处又吃亏一提交</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>()) &#123;<br>            <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, t.<span class="hljs-built_in">size</span>());<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> len = INT_MAX, ansL = <span class="hljs-number">-1</span>;<br>		<span class="hljs-comment">// 下面是经典的 “窗口滑动” 就是模拟右移</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = t.<span class="hljs-built_in">size</span>(); i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            Cnt[s[i]]--;<br>			<span class="hljs-comment">// 这里必须是while, 因为当前窗口可能含有多个t串中的字符, 要求最小值就让left一直收缩, 直到不符合</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>()) &#123;<br>				<span class="hljs-comment">// 此处用len 和 ansL 来代替直接 substr子串然后和res子串比较  --&gt; 在此处吃亏 内存限制</span><br>                <span class="hljs-keyword">if</span> (i - left &lt; len) &#123;<br>                    len = i - left;<br>                    ansL = left;<br>                &#125;<br>                Cnt[s[left]]++;<br>                left++;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">// ansL == -1 代表没有符合的</span><br>        <span class="hljs-keyword">return</span> ansL == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(ansL, len + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>几次的错误提交原因</code> </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 忘了求最小值，没判断所以返回的最后一个符合的<br><span class="hljs-bullet">2.</span> 判空<br><span class="hljs-bullet">3.</span> 判单个字符<br><span class="hljs-bullet">4.</span> 超出内存限制 --&gt;  不用substr记录每一个，选择len记录长度，最后返回的时候用一下substr可以解决<br></code></pre></td></tr></table></figure>

<h3 id="2023-11-02-21-27-总结"><a href="#2023-11-02-21-27-总结" class="headerlink" title="2023/11/02 21:27 总结"></a>2023/11/02 21:27 总结</h3><p><code>今日题目完成数</code> ： 4<br><code>类型</code> ： 模拟 * 1、 滑动窗口 * 3<br><code>成果 &amp; 经验</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">主要是三道滑动窗口题目,思路都大概相似：<br><span class="hljs-number">1.</span> 哈希表记录目标字符串和当前窗口的字符串的状态<br><span class="hljs-number">2.</span> 窗口移动, left侧的内容会被移出， right侧的会被加入<br><span class="hljs-number">3.</span> 优化: 一些题目可以减少哈希表的使用 如使用一个diff, cnt, 用记录差异的方式省去空间<br></code></pre></td></tr></table></figure>

<h2 id="2023-11-03"><a href="#2023-11-03" class="headerlink" title="2023/11/03"></a>2023/11/03</h2><h3 id="【每日打卡】填充每个节点的下一个右侧节点指针-II-（中等）"><a href="#【每日打卡】填充每个节点的下一个右侧节点指针-II-（中等）" class="headerlink" title="【每日打卡】填充每个节点的下一个右侧节点指针 II （中等）"></a>【每日打卡】填充每个节点的下一个右侧节点指针 II （中等）</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/</a>  </p>
<p>一个经典的 <code>层序遍历</code> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        queue&lt;Node*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>			<span class="hljs-comment">// 用一个last来记录当前这一层的最后一个节点</span><br>            Node* last = q.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">while</span> (n--) &#123;<br>                Node* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>				<span class="hljs-comment">// last初始化为的front, 所以要跳过第一个</span><br>                <span class="hljs-keyword">if</span> (last != cur) &#123;<br>                    last-&gt;next = cur;<br>                &#125;<br>                last = cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以优化一下，不需要queue，而是用链表来存储某一层的所有节点<br>QAQ 感觉不用注释了吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        Node *next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        Node *cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            next-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            Node *nxt = next;<br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                    nxt-&gt;next = cur-&gt;left;<br>                    nxt = cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>                    nxt-&gt;next = cur-&gt;right;<br>                    nxt = cur-&gt;right;<br>                &#125;<br>                cur = cur-&gt;next;<br>            &#125;<br>            cur = next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> next;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="396-旋转函数-（中等）"><a href="#396-旋转函数-（中等）" class="headerlink" title="396. 旋转函数 （中等）"></a>396. 旋转函数 （中等）</h3><p><a href="https://leetcode.cn/problems/rotate-function/">https://leetcode.cn/problems/rotate-function/</a><br>其实应该是个滑动窗口的题，但是~ 发现了规律</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">nums:</span> [<span class="hljs-built_in">A0</span>,<span class="hljs-built_in">A1</span>,<span class="hljs-built_in">A2</span>,<span class="hljs-built_in">A3</span>]<br><br>F0 = <span class="hljs-number">0</span>*<span class="hljs-built_in">A0</span> + <span class="hljs-number">1</span>*<span class="hljs-built_in">A1</span> + <span class="hljs-number">2</span>*<span class="hljs-built_in">A2</span> + <span class="hljs-number">3</span>*<span class="hljs-built_in">A3</span><br><br>F1 = <span class="hljs-number">0</span>*<span class="hljs-built_in">A3</span> + <span class="hljs-number">1</span>*<span class="hljs-built_in">A0</span> + <span class="hljs-number">2</span>*<span class="hljs-built_in">A1</span> + <span class="hljs-number">3</span>*<span class="hljs-built_in">A2</span> <br>   = F0 + <span class="hljs-built_in">A0</span> + <span class="hljs-built_in">A1</span> + <span class="hljs-built_in">A2</span> - <span class="hljs-number">3</span>*<span class="hljs-built_in">A3</span> <br>   = F0 + sum-<span class="hljs-built_in">A3</span> - <span class="hljs-number">3</span>*<span class="hljs-built_in">A3</span> <br>   = F0 + sum - <span class="hljs-number">4</span>*<span class="hljs-built_in">A3</span><br><br>F2 = <span class="hljs-number">0</span>*<span class="hljs-built_in">A2</span> + <span class="hljs-number">1</span>*<span class="hljs-built_in">A3</span> + <span class="hljs-number">2</span>*<span class="hljs-built_in">A0</span> + <span class="hljs-number">3</span>*<span class="hljs-built_in">A1</span> <br>   = F1 + <span class="hljs-built_in">A3</span> + <span class="hljs-built_in">A0</span> + <span class="hljs-built_in">A1</span> - <span class="hljs-number">3</span>*<span class="hljs-built_in">A2</span> <br>   = F1 + sum - <span class="hljs-number">4</span>*<span class="hljs-built_in">A2</span><br><br>F3 = <span class="hljs-number">0</span>*<span class="hljs-built_in">A1</span> + <span class="hljs-number">1</span>*<span class="hljs-built_in">A2</span> + <span class="hljs-number">2</span>*<span class="hljs-built_in">A3</span> + <span class="hljs-number">3</span>*<span class="hljs-built_in">A0</span> <br>   = F2 + <span class="hljs-built_in">A2</span> + <span class="hljs-built_in">A3</span> + <span class="hljs-built_in">A0</span> - <span class="hljs-number">3</span>*<span class="hljs-built_in">A1</span> <br>   = F2 + sum - <span class="hljs-number">4</span>*<span class="hljs-built_in">A1</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxRotateFunction</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum += nums[i];<br>            f += i * nums[i];<br>        &#125;<br>        res = f;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>			<span class="hljs-comment">// 推出的结论</span><br>            f = f + sum - n * nums[n - i];<br>            res = <span class="hljs-built_in">max</span>(f, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1508-子数组和排序后的区间和-（中等-–-1402）"><a href="#1508-子数组和排序后的区间和-（中等-–-1402）" class="headerlink" title="1508. 子数组和排序后的区间和 （中等 – 1402）"></a>1508. 子数组和排序后的区间和 （中等 – 1402）</h3><p><code>模拟</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>		<span class="hljs-comment">// 根据排列组合 最终结果数就是这些</span><br>        <span class="hljs-keyword">int</span> len = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sums</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>		<span class="hljs-comment">// 双层for遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                sum += nums[j];<br>				<span class="hljs-comment">// 每次把结果加进来</span><br>                sums[index++] = sum;<br>            &#125;<br>        &#125;<br>		<span class="hljs-comment">// 朴实无华的排序</span><br>        <span class="hljs-built_in">sort</span>(sums.<span class="hljs-built_in">begin</span>(), sums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left - <span class="hljs-number">1</span>; i &lt; right; i++) &#123;<br>			<span class="hljs-comment">// 毫无技术含量的累加</span><br>            res = (res + sums[i]) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1985-找出数组中的第-K-大整数-（中等-–-1414）"><a href="#1985-找出数组中的第-K-大整数-（中等-–-1414）" class="headerlink" title="1985. 找出数组中的第 K 大整数 （中等 – 1414）"></a>1985. 找出数组中的第 K 大整数 （中等 – 1414）</h3><p><a href="https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/">https://leetcode.cn/problems/find-the-kth-largest-integer-in-the-array/</a><br><code>自定义排序函数</code>解决,但是只击败了(13%,9.5%), 没看大佬们用的啥，感觉这个题也没必要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">kthLargestNumber</span><span class="hljs-params">(vector&lt;string&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>		<span class="hljs-comment">// lambda表达式</span><br>        <span class="hljs-keyword">auto</span> cmp = [&amp;] (string s1, string s2) &#123;<br>            <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>() ? <span class="hljs-literal">true</span> : s1.<span class="hljs-built_in">size</span>() == s2.<span class="hljs-built_in">size</span>() ? s1 &gt; s2 : <span class="hljs-literal">false</span>;<br>        &#125;;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>小回顾一下。 但是没必要非得用lambda表达式，用函数作用基本一样</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">目前我就用过两种情况<br><span class="hljs-number">1</span>. auto <span class="hljs-string">&quot;name&quot;</span> = [&amp;] (<span class="hljs-regexp">/参数/</span>) &#123; <span class="hljs-regexp">/code/</span> &#125;;<br><span class="hljs-number">2</span>. <span class="hljs-keyword">function</span>&lt;T(T)&gt; <span class="hljs-string">&quot;name&quot;</span> = [&amp;] (T) &#123; <span class="hljs-regexp">/code/</span> &#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2023-11-03-21-51-总结"><a href="#2023-11-03-21-51-总结" class="headerlink" title="2023/11/03 21:51 总结"></a>2023/11/03 21:51 总结</h3><p><code>今日题目完成数</code> ： 4<br><code>类型</code> ： 模拟 * 2、 规律(滑窗) * 1， 树(层序遍历) * 1<br><code>成果 &amp; 经验</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">今天做的题都比较简单<br><span class="hljs-number">1.</span> 模拟就是照着描述实现<br><span class="hljs-number">2.</span> 规律题找到就简单，想不到就G。 还是得用通用，明天有空写一下。<br><span class="hljs-number">3.</span> 树的遍历比较熟悉，所以做起来显得简单。 空间优化是该想到的！<br></code></pre></td></tr></table></figure>

<h2 id="2023-11-04"><a href="#2023-11-04" class="headerlink" title="2023/11/04"></a>2023/11/04</h2><h3 id="【每日打卡】421-数组中两个数的最大异或值-（中等）"><a href="#【每日打卡】421-数组中两个数的最大异或值-（中等）" class="headerlink" title="【每日打卡】421. 数组中两个数的最大异或值 （中等）"></a>【每日打卡】421. 数组中两个数的最大异或值 （中等）</h3><p><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array</a>  </p>
<p>思路： 首先想到暴力 –&gt; 寄，超时</p>
<p>看到了<code>异或</code>可以想到位运算相关的操作, 可参考之前的一篇 <a href="https://kkkeria.github.io/2023/10/14/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a><br>想要最大的异或值, 那么什么时候最大 –&gt; <code>最高位</code>尽量是一个是 1 另一个是 0 来异或 可以让这一位结果是 1, 然后找<code>次高位</code>。以此类推</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> HIGH_BIT = <span class="hljs-number">30</span>; <span class="hljs-comment">// 第一次定的最高位。因为是int 所以定为30, 后来有优化。</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 在此处优化，只需求nums中最大值的最高位的位置</span><br>        <span class="hljs-keyword">int</span> mx = *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// __builtin_clz是求 mx的前导0的数量(二进制下)</span><br>        <span class="hljs-keyword">int</span> high_bit = mx ? <span class="hljs-number">31</span> - __builtin_clz(mx) : <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, mask = <span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = high_bit; i &gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            s.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-comment">// 1左移i位， 也就是让 i + 1位变成1其余都是0</span><br>            <span class="hljs-comment">// 1 &lt;&lt; 2  =  100</span><br>            mask |= <span class="hljs-number">1</span> &lt;&lt; i;<br><br>            <span class="hljs-keyword">int</span> new_ans = res | (<span class="hljs-number">1</span> &lt;&lt; i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num :nums) &#123;<br>                <span class="hljs-comment">// 遍历到的这个数和mask的这个操作可以得到第i + 1位上的状态（是1还是0）</span><br>                num &amp;= mask;<br>                <span class="hljs-comment">// 这一步可以照着 力扣经典题目 “两数之和” 来理解</span><br>                <span class="hljs-comment">// 那个是 count(target - x) 即目标值 减去 当前值， 因为  x + y = target --&gt; y = target - x</span><br>                <span class="hljs-comment">// 这个是异或， 所以 x ^ y = target --&gt;  y = target ^ x (异或还是看上面的那个链接)</span><br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(new_ans ^ num)) &#123;<br>                    res = new_ans; <span class="hljs-comment">// 能找到就说明有符合能让这一位是1的两个数</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                s.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="869-重新排序得到-2-的幂-（中等-–-1505）"><a href="#869-重新排序得到-2-的幂-（中等-–-1505）" class="headerlink" title="869. 重新排序得到 2 的幂 （中等 – 1505）"></a>869. 重新排序得到 2 的幂 （中等 – 1505）</h3><p><a href="https://leetcode.cn/problems/reordered-power-of-2/description/">https://leetcode.cn/problems/reordered-power-of-2/description/</a><br>思路： 就是一个全排列问题 得到结果再加一步判断是不是2的幂</p>
<p>全排列就是 回溯 + 剪枝 优化  (O(m!) &amp; O(m))<br>但是只击败 20% 多, 可能是因为 官解的另一个做法 预处理 + 哈希表（O(log(n)) &amp; O(1)）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPowOfTwo</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 剪枝, 分别对应的情况是 </span><br>            <span class="hljs-comment">// 前导0  &amp;&amp;  访问过 &amp;&amp; 前一个没访问过，但是当前位置和前一个相同(剪枝去重)</span><br>            <span class="hljs-keyword">if</span> ((num == <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) || vis[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; !vis[i - <span class="hljs-number">1</span>] &amp;&amp; s[i] == s[i - <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(s, index + <span class="hljs-number">1</span>, num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reorderedPowerOf2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-comment">// 先排序一下，方便剪枝</span><br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        vis.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2761-和等于目标值的质数对-（中等-–-1505）"><a href="#2761-和等于目标值的质数对-（中等-–-1505）" class="headerlink" title="2761. 和等于目标值的质数对 （中等 – 1505）"></a>2761. 和等于目标值的质数对 （中等 – 1505）</h3><p><a href="https://leetcode.cn/problems/prime-pairs-with-target-sum/">https://leetcode.cn/problems/prime-pairs-with-target-sum/</a>  </p>
<p>思路：先打表得到范围内所有素数， 然后对 (x, n - x) 进行判断，条件是 都是素数即可返回</p>
<p><code>素数筛</code> 之 <code>埃氏筛</code>， 模板可直接用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MX = <span class="hljs-number">1e6</span>; <span class="hljs-comment">// 范围</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; primes; <span class="hljs-comment">// 得到的所有素数</span><br> <span class="hljs-keyword">bool</span> not_Prime[MX + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 一个bool数组, not_Prime[i]代表i不是素数</span><br><span class="hljs-comment">// vector&lt;bool&gt; not_Prime(MX + 1, true);</span><br><span class="hljs-keyword">int</span> init = []() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= MX; i++) &#123;<br>        <span class="hljs-comment">// 从2开始遍历，如果i是素数就进入</span><br>        <span class="hljs-keyword">if</span> (!not_Prime[i]) &#123;<br>            <span class="hljs-comment">// 先把i加到结果</span><br>            primes.<span class="hljs-built_in">emplace_back</span>(i);<br>            <span class="hljs-comment">// 这一步代表把 i 的倍数全标记为不是素数</span><br>            <span class="hljs-comment">// 如2是素数 那么 4,6,8,10 肯定就都不是</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= MX / i; j++) &#123;<br>                not_Prime[i * j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;();<br></code></pre></td></tr></table></figure>
<p><code>素数筛</code> 之 <code>线性筛(欧拉筛)</code>， 模板可直接用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">也有板子，懒得找了。<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> MX = <span class="hljs-number">1e6</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; primes;<br> <span class="hljs-keyword">bool</span> not_Prime[MX + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// vector&lt;bool&gt; not_Prime(MX + 1, true);</span><br><span class="hljs-keyword">int</span> init = []() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= MX; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!not_Prime[i]) &#123;<br>            primes.<span class="hljs-built_in">emplace_back</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= MX / i; j++) &#123;<br>                not_Prime[i * j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;();<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findPrimePairs</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">// 这里进行了一点优化, 如果n是奇数 那么想得到两个素数的结果 只能是 (2, n - 2) 且两个都是素数，因为偶数肯定不是素数（除了2）</span><br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">4</span> &amp;&amp; !not_Prime[n - <span class="hljs-number">2</span>]) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>&#125;);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : primes) &#123;<br>            <span class="hljs-keyword">int</span> y = n - x;<br>            <span class="hljs-keyword">if</span> (y &lt; x) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!not_Prime[y]) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;x, y&#125;);<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1780-判断一个数字是否可以表示成三的幂的和-（中等-–-1506）"><a href="#1780-判断一个数字是否可以表示成三的幂的和-（中等-–-1506）" class="headerlink" title="1780. 判断一个数字是否可以表示成三的幂的和 （中等 – 1506）"></a>1780. 判断一个数字是否可以表示成三的幂的和 （中等 – 1506）</h3><p><a href="https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/">https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/</a>  </p>
<p>思路：模仿二进制 –&gt; 三进制</p>
<p>太简单辣，不写注释了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkPowersOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) &#123;<br>                n /= <span class="hljs-number">3</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1253-重构-2-行二进制矩阵-（中等-–-1506）"><a href="#1253-重构-2-行二进制矩阵-（中等-–-1506）" class="headerlink" title="1253. 重构 2 行二进制矩阵 （中等 – 1506）"></a>1253. 重构 2 行二进制矩阵 （中等 – 1506）</h3><p><a href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/</a>  </p>
<p>思路：一开始看错题了还觉得挺难, 这个是二进制数组只有 0 1 那就简单多了</p>
<p>存在符合的情况:</p>
<ol>
<li>colsum = 2  说明上下都是1</li>
<li>colsum = 1  可以上为1也可以下为1 这里使用<code>贪心</code>的思想，upper 和 lower谁大就优先给哪一边</li>
<li>colsum = 0  都是0</li>
</ol>
<p>不存在符合的情况：</p>
<ol>
<li>colsum的总和大于 upper + lower</li>
<li>colsum中2的数目比 min(upper, lower)</li>
</ol>
<p>但是这两种情况可以用一种写法判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">reconstructMatrix</span>(<span class="hljs-keyword">int</span> upper, <span class="hljs-keyword">int</span> lower, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; colsum) &#123;<br>        <span class="hljs-keyword">int</span> n = colsum.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(<span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (colsum[i] == <span class="hljs-number">2</span>) &#123;<br>                res[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>                res[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>                upper--;<br>                lower--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colsum[i] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">//  优先给大的一边分配</span><br>                <span class="hljs-keyword">if</span> (upper &gt;= lower) &#123;<br>                    upper--;<br>                    res[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    lower--;<br>                    res[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 当还没遍历完 upper 和 lower中的某一个已经分配完了，就说明是不能满足要求</span><br>            <span class="hljs-keyword">if</span> (upper &lt; <span class="hljs-number">0</span> || lower &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123;&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (upper == <span class="hljs-number">0</span> &amp;&amp; lower == <span class="hljs-number">0</span>) ? res : vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1387-将整数按权重排序-（中等-–-1507）"><a href="#1387-将整数按权重排序-（中等-–-1507）" class="headerlink" title="1387. 将整数按权重排序 （中等 – 1507）"></a>1387. 将整数按权重排序 （中等 – 1507）</h3><p><a href="https://leetcode.cn/problems/sort-integers-by-the-power-value/">https://leetcode.cn/problems/sort-integers-by-the-power-value/</a>  </p>
<p>思路：简单的模拟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; pii;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;pii&gt; cnt;<br>        <span class="hljs-comment">// getX用来获取 “权重”, 权重的定义见题目描述</span><br>        <span class="hljs-keyword">auto</span> getX = [&amp;] (<span class="hljs-keyword">int</span> n) &#123;<br>            <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>                    n = n * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    n /= <span class="hljs-number">2</span>;<br>                &#125;<br>                res++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">// 遍历, 然后把 (i, i的权重) 加入到cnt中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt;= hi; i++) &#123;<br>            cnt.<span class="hljs-built_in">push_back</span>(&#123;i, <span class="hljs-built_in">getX</span>(i)&#125;);<br>        &#125;<br>        <span class="hljs-comment">// 自定义函数 根据题目描述 权重一样要按原值排序</span><br>        <span class="hljs-keyword">auto</span> cmp = [&amp;] (pii a, pii b) &#123;<br>            <span class="hljs-keyword">if</span> (a.second == b.second) &#123;<br>                <span class="hljs-keyword">return</span> a.first &lt; b.first;<br>            &#125;<br>            <span class="hljs-keyword">return</span> a.second &lt; b.second;<br>        &#125;;<br>        <span class="hljs-built_in">sort</span>(cnt.<span class="hljs-built_in">begin</span>(), cnt.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">return</span> cnt[k - <span class="hljs-number">1</span>].first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2105-给植物浇水-II-（中等-–-1507）"><a href="#2105-给植物浇水-II-（中等-–-1507）" class="headerlink" title="2105. 给植物浇水 II （中等 – 1507）"></a>2105. 给植物浇水 II （中等 – 1507）</h3><p><a href="https://leetcode.cn/problems/watering-plants-ii/">https://leetcode.cn/problems/watering-plants-ii/</a>  </p>
<p>思路：简单的模拟 –&gt; 双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumRefill</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; plants, <span class="hljs-keyword">int</span> capacityA, <span class="hljs-keyword">int</span> capacityB)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = plants.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> curA = capacityA, curB = capacityB;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-comment">// 相等代表相遇了, 谁剩的多谁来浇，不够的话一个人去补就够 也就是res++然后退出。</span><br>            <span class="hljs-keyword">if</span> (left == right) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(curA, curB) &lt; plants[left]) &#123;<br>                    res++;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 不够就去补满 然后res++</span><br>            <span class="hljs-keyword">if</span> (curA &lt; plants[left]) &#123;<br>                res++;<br>                curA = capacityA;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (curB &lt; plants[right]) &#123;<br>                res++;<br>                curB = capacityB;<br>            &#125;<br>            curA -= plants[left++];<br>            curB -= plants[right--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2023-11-04-23-37-总结"><a href="#2023-11-04-23-37-总结" class="headerlink" title="2023/11/04 23:37 总结"></a>2023/11/04 23:37 总结</h3><p><code>今日题目完成数</code> ： 7<br><code>类型</code> ： 模拟 * 4、 dfs回溯  * 1、 位运算 * 1、 贪心 * 1<br><code>成果 &amp; 经验</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 回顾了一下dfs回溯的问题，想到了当时刷 POJ 的日子，一段时间没刷这种，还是有点忘了，明天再刷两个。<br><span class="hljs-number">2.</span> 模拟题还行，这都是些简单的模拟。选对数据结构就okk<br><span class="hljs-number">3.</span> 出现了素数的问题，我之前的欧拉筛板子是c版本的太丑了，此处借鉴了灵神的板子，欧拉筛的复杂度应该是更低，但是我觉得埃氏筛够用了，而且好理解。<br><br><span class="hljs-number">4.</span> <span class="hljs-number">1500</span>+的题还是SO EZ啊<br></code></pre></td></tr></table></figure>

<h2 id="未完……"><a href="#未完……" class="headerlink" title="未完……"></a>未完……</h2>]]></content>
      <categories>
        <category>code日记</category>
      </categories>
  </entry>
</search>
