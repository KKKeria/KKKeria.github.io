<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>4.9-力扣-780到达终点(困难)</title>
    <url>/2022/04/09/4-9-%E5%8A%9B%E6%89%A3-780%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-%E5%9B%B0%E9%9A%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。<br>从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过要求可以看出 (x,y) -&gt; (x, x + y) 或者 (x + y, y);那么可以反推得<br>(tx,ty) 的前身一定是(tx - a, ty) 或者(tx, ty - a) 其中a是上一层的tx或者ty;<br>以测试用例1来说明</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br>输入: sx = <span class="hljs-number">1</span>, sy = <span class="hljs-number">1</span>, tx = <span class="hljs-number">3</span>, ty = <span class="hljs-number">5</span><br>输出: <span class="hljs-literal">true</span><br>解释:<br>可以通过以下一系列转换从起点转换到终点：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">tx		ty<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span><br>.		.<br>.		.<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span> <span class="hljs-comment">% 3 //因为这里可以加相同的tx无数次来达到ty</span><br>.		.<br>.		.<br><span class="hljs-number">3</span> <span class="hljs-comment">% 2	2//同理 此时已经有了一边和sx 或者 sy相等，也就是从二元变成了一元，只需判断能否除余得0即可</span><br>[注]一定是大的除余小的，原因很简单......<br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reachingPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sx, <span class="hljs-keyword">int</span> sy, <span class="hljs-keyword">int</span> tx, <span class="hljs-keyword">int</span> ty)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tx &lt; sx || ty &lt; sy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (tx &gt; ty) &#123;<br>            <span class="hljs-keyword">if</span> (sy == ty)    <br>                <span class="hljs-keyword">return</span> sx &gt;= (tx % ty) &amp;&amp; (tx - sx) % sy == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx % ty, ty);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tx &lt; ty)&#123;<br>            <span class="hljs-keyword">if</span> (sx == tx)    <br>                <span class="hljs-keyword">return</span> sy &gt;= (ty % tx) &amp;&amp; (ty - sy) % sx == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx, ty % tx);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tx == sx &amp;&amp; ty == sy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2021/10/26/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="17电话号码的字母组合"><a href="#17电话号码的字母组合" class="headerlink" title="17电话号码的字母组合"></a>17电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。(九键输入法)</p>
<p>思路：九宫格每个数字（2-9）分别对应相应的字母 很显然要用哈希表将他们联系起来</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>          &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>      &#125;;<br></code></pre></td></tr></table></figure>
<p>因为是要求出所有的可能，首先想到的就是递归,回溯,dfs.代码分为两块</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> == <span class="hljs-built_in">digits</span>.<span class="hljs-built_in">size</span>()) &#123;<br>          res.push_back(tmp);<br>      &#125; //长度够了后返回结果<br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">char digit = digits[index]; <span class="hljs-regexp">//</span>输入数字的索引<br>string letters = pair[digit];<span class="hljs-regexp">//</span>输入数字对应的字母的字符串<br><span class="hljs-keyword">for</span>(auto l : letters) &#123; <span class="hljs-regexp">//</span>对每一个遍历<br>    tmp.push_back(l);<span class="hljs-regexp">//</span>tmp数组push <span class="hljs-string">&#x27;l&#x27;</span><br>    dfs(pair,index + <span class="hljs-number">1</span>,digits); <span class="hljs-regexp">//</span>递归 index++表示着要和下一个数字匹配<br>    tmp.pop_back();<span class="hljs-regexp">//</span>回溯（关键） 有点类似于树<br>&#125; <span class="hljs-regexp">//</span>处理过程<br></code></pre></td></tr></table></figure>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>            &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(pair,<span class="hljs-number">0</span>,digits);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair,<span class="hljs-keyword">int</span> index,string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">char</span> digit = digits[index];<br>        string letters = pair[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : letters) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(l);<br>            <span class="hljs-built_in">dfs</span>(pair,index + <span class="hljs-number">1</span>,digits);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22括号生成"><a href="#22括号生成" class="headerlink" title="22括号生成"></a>22括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<p>思路:有了上一个题的经验,但是这个没有什么需要处理的，直接进入dfs环节（因为只有左右括号一说）<br>还是分为两块</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(tmp.size() == n * <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.push_back</span>(tmp);<br>      &#125;<span class="hljs-comment">//因为是左右括号，每添加一次就会++ 而给的n代表的是括号对数</span><br></code></pre></td></tr></table></figure>
<p>然后又到了如何处理和回溯阶段</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">		<span class="hljs-selector-tag">if</span>(left &lt; n) &#123;<span class="hljs-comment">//首先只要左括号数小于n 一直加左括号 直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125;<br>        <span class="hljs-selector-tag">if</span>(right &lt; left) &#123;<span class="hljs-comment">//直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125; <span class="hljs-comment">//同样这两个都是用pop_back进行回溯</span><br><span class="hljs-comment">//过程大概就是 左括号三个 对应的右括号的情况 然后两个左括号在对应有括号（右括号必须小于左括号）</span><br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &lt; n) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; left) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="37解数独"><a href="#37解数独" class="headerlink" title="37解数独"></a>37解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 遵循如下规则：<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>思路：乍一看这个题是困难题,而且貌似非常复杂,其实也要遵循“标准”步骤<br>同样的道理,没有需要处理的就直接进入dfs</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//因为这个的停止条件就是遍历完全部，所以省去第一步 直接到如何处理和回溯</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-comment">//双层for找到需要判断的&quot;格子&quot;</span><br>               <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//不是空格就继续</span><br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123; <span class="hljs-comment">//假如是空格，这里有点类似第一个的 &#x27;2&#x27;代表 &quot;abc&quot; 这里的空格代表 0 - 9</span><br>                   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<span class="hljs-comment">//这里是题目的条件，要求填入的数合法,在回溯问题中可视为已知，这就可以类比为普通的dfs问题</span><br>                       board[i][j] = ch;<span class="hljs-comment">//填上相应数字</span><br>                       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//递归，如果最后返回true就说明有解</span><br>                       board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//回溯 </span><br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>判断的函数也是非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(board);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<br>                        board[i][j] = ch;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs回溯</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>edge扩展</title>
    <url>/2022/07/26/edge%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="edge不能下载扩展的解决方法"><a href="#edge不能下载扩展的解决方法" class="headerlink" title="edge不能下载扩展的解决方法"></a>edge不能下载扩展的解决方法</h2><h3 id="1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com"><a href="#1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com" class="headerlink" title="1- https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com"></a>1- <a href="https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com">https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com</a></h3><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">打开此网站，选择延迟较低<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure>
<h3 id="2-C-Windows-System32-drivers-etc"><a href="#2-C-Windows-System32-drivers-etc" class="headerlink" title="2- C:\Windows\System32\drivers\etc"></a>2- C:\Windows\System32\drivers\etc</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">找到此路径下的hosts文件，在最先面添加 <br><span class="hljs-number">116.55</span>.<span class="hljs-number">252.94</span> msedgeextensions<span class="hljs-selector-class">.sf</span><span class="hljs-selector-class">.tlu</span><span class="hljs-selector-class">.dl</span><span class="hljs-selector-class">.delivery</span><span class="hljs-selector-class">.mp</span><span class="hljs-selector-class">.microsoft</span><span class="hljs-selector-class">.com</span> #Edge商店扩展<br><span class="hljs-selector-attr">[注]</span>前面为复制的ip 后面是商店扩展的url，如果别的有问题也可以替换为别的<br></code></pre></td></tr></table></figure>
<h3 id="3-管理员身份打开cmd-输入-ipconfig-flushdns"><a href="#3-管理员身份打开cmd-输入-ipconfig-flushdns" class="headerlink" title="3- 管理员身份打开cmd 输入 ipconfig /flushdns"></a>3- 管理员身份打开cmd 输入 ipconfig /flushdns</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">客户端查询DNS的过程是：<br><br>本地host文件—本地缓存—-DNS服务器<br><br>Ｈost文件用于本地DNS解析，并且优先于寻找网络上的DNS服务器<br><br>在Windows中，它的目录通常在[Windows目录]\system32\drivers\etc\下。<br><br><span class="hljs-symbol">Hosts</span>文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/<span class="hljs-built_in">IP</span> for Windows 的标准来工作的，它的作用是包含<span class="hljs-built_in">IP</span>地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，<span class="hljs-built_in">IP</span>地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> localhost.<br><br>我们知道，当电脑访问网站时，首先通过DNS服务器把网络 域名解析成<span class="hljs-built_in">IP</span>地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回<span class="hljs-built_in">IP</span>，访问速度就会比较慢，而Hosts文件正可以解决这个 问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个<span class="hljs-built_in">IP</span>地址映射，如果没有再向DNS服 务器提出域名解析。<br><br>对于要经常访问的网站和用于测试服务，我们可以通过在Hosts中配置域名和<span class="hljs-built_in">IP</span>的映射关系，这样当我们输入域名计算机就能很快解析出<span class="hljs-built_in">IP</span>，而不用请求网络上的DNS服务器。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/11/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="第-267-场周赛-5929-处理含限制条件的好友请求"><a href="#第-267-场周赛-5929-处理含限制条件的好友请求" class="headerlink" title="第 267 场周赛 5929. 处理含限制条件的好友请求"></a>第 267 场周赛 5929. 处理含限制条件的好友请求</h2><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。<br>一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p>
<span id="more"></span>
<h2 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <span class="hljs-keyword">int</span> n;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">parent</span>(_n), <span class="hljs-built_in">size</span>(_n, <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(), parent.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<span class="hljs-comment">//给parent累加赋值 0,1,2......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">//找到x的最高树节点</span><br>        <span class="hljs-keyword">return</span> parent[x] == x ? x : parent[x] = <span class="hljs-built_in">findset</span>(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//成为朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-comment">//已经是就不用操作</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y]) &#123;并查集，维护树高，把矮的往高的合并再加上路径优化可以得到最优的复杂度<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//判断是否是朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="题目实现代码-注释"><a href="#题目实现代码-注释" class="headerlink" title="题目实现代码 + 注释"></a>题目实现代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">friendRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; re, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; qu)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt; res;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//初始化并查集类 并且赋初值n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qu.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//遍历每一个成为朋友的请求request</span><br>            <span class="hljs-keyword">int</span> x = qu[i][<span class="hljs-number">0</span>], y = qu[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// x,y分别获取值</span><br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用于判断能否成为朋友，即是否被限制（restrictions）</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">connected</span>(x, y))&#123;<span class="hljs-comment">//如果不满足这个条件说明两个人已经是朋友，就不用了进行判断，直接push_back</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; re.<span class="hljs-built_in">size</span>(); ++j)&#123;<span class="hljs-comment">//如果满足就对每一条限制(resstriction)进行判断</span><br>                    <span class="hljs-keyword">int</span> p = re[j][<span class="hljs-number">0</span>], q = re[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>((uf.<span class="hljs-built_in">connected</span>(p, x) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, y))<br>                      || (uf.<span class="hljs-built_in">connected</span>(p, y) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, x)))&#123;<span class="hljs-comment">//限制条件 P-X &amp;&amp; Q-Y则 X-Y不能成立</span><br>                        f = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果存在一种不能成立的 就让f = false 代表不能成为朋友</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)&#123; <span class="hljs-comment">//true就 unite(让两个成为朋友) push_back true;</span><br>                uf.<span class="hljs-built_in">unite</span>(x, y);<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则就 push_back false;</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>最小堆（优先队列 priority_queue）</title>
    <url>/2021/11/03/%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20priority_queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="11-03-407-接雨水-II"><a href="#11-03-407-接雨水-II" class="headerlink" title="11-03 407. 接雨水 II"></a>11-03 407. 接雨水 II</h2><p>给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的。我们可以知道容器内水的高度取决于最外层高度最低的方块，如图所示：<br><img src="/img/P1.png" alt="来自LeetCode"><br>我们假设已经知道最外层的方块接水后的高度的最小值，则此时我们根据木桶原理，肯定可以确定最小高度方块的相邻方块的接水高度。<br>我们同时更新外层的方块标记，我们在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度，如图所示:<br><img src="/img/P2.png" alt="来自LeetCode"><br>然后再次更新最外层，依次迭代直到求出所有的方块的接水高度，即可知道矩阵中的接水容量。 这里使用到了一种数据结构—最小堆</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆也叫优先队列，堆是一种特殊的完全二叉树数据结<br>堆分为两种，最大堆，最小堆。<br>最大堆：根节点大于左右两个子节点的完全二叉树<br>最小堆：根节点小于左右两个子节点的完全二叉树<br>堆可以用数组来存储，<br>a[i]处存根节点，a[2 * i]存左子树的根节点 ; a[2 * i + 1]存右子树的根节点。i从1开始!!<br><img src="/img/P3.png" alt="完全二叉树"></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++ STL实现的优先级队列是一种容器适配器，类似堆，可以随时插入元素，但只能检索到优先级队列中优先级最高的元素。<br>priority_queue&lt;int,vector,less&gt; q;最大堆（默认为最大堆）<br>priority_queue&lt;int,vector,greater&gt; q;最小堆</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; small_heap; <span class="hljs-comment">//最小堆定义方法</span><br>第一个参数T：元素（element）类型<br>第二个参数Container：必须是容器类型Container，用来存储元素（element），其类型必须是第一个参数<br>第三个参数Compare：比较形式，默认是less<br><br>q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回q里元素个数</span><br>q.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.<span class="hljs-built_in">push</span>(k);<span class="hljs-comment">//在q的末尾插入k</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure>

<h2 id="完整代码-详细注释"><a href="#完整代码-详细注释" class="headerlink" title="完整代码 + 详细注释"></a>完整代码 + 详细注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trapRainWater</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> row = heightMap.<span class="hljs-built_in">size</span>(), col = heightMap[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">3</span> || col &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//不足 3X3不可能接到水</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; minHeap;<span class="hljs-comment">//最小堆定义，</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == row - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == col - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//最外围一圈不可能接到水，先入队列</span><br>                    minHeap.<span class="hljs-built_in">push</span>(&#123;heightMap[i][j], i * col + j&#125;);<span class="hljs-comment">//i * col + j以这种方式存储</span><br>                    vis[i][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//vis数组来记录访问</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; direction =  &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向--左、上、右、下</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; tmp = minHeap.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//定义一个临时变量获取队列top()值</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">//四个方向分别遍历</span><br>                <span class="hljs-keyword">int</span> nextrow = tmp.second / col + direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> nextcol = tmp.second % col + direction[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//下一个的坐标 i，j值，承接上面的存储方法</span><br><br>            <span class="hljs-keyword">if</span>(nextrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nextrow &lt; row &amp;&amp; nextcol &gt;= <span class="hljs-number">0</span> &amp;&amp; nextcol &lt; col &amp;&amp; !vis[nextrow][nextcol]) &#123; <span class="hljs-comment">//首先得在范围内 并且未被访问</span><br>                    <span class="hljs-keyword">if</span>(heightMap[nextrow][nextcol] &lt; tmp.first) &#123; <span class="hljs-comment">//最小堆的特性，最小值，如果符合条件就说明存在“木桶” </span><br>                        res += tmp.first - heightMap[nextrow][nextcol];<span class="hljs-comment">//结果加上</span><br>                    &#125;<br>                vis[nextrow][nextcol] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//代表已经访问</span><br>                minHeap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">max</span>(heightMap[nextrow][nextcol], tmp.first), nextrow * col + nextcol&#125;);<span class="hljs-comment">//访问后放入最小堆</span><br>                &#125;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>洗牌算法-随机打乱数组</title>
    <url>/2021/11/22/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>Inside-Out Algorithm 算法的基本思路是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k）<br>这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p>
<span id="more"></span>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">RandomAccessIterator</span>&gt;                                             <br><span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">random_shuffle</span>(<span class="hljs-symbol">RandomAccessIterator</span> <span class="hljs-symbol">first, <span class="hljs-symbol">RandomAccessIterator</span></span> <span class="hljs-symbol">last</span>) &#123; <br>    <span class="hljs-keyword">if</span>(first != last)                                                             <br>        <span class="hljs-keyword">for</span>(RandomAccessIterator i = first + <span class="hljs-number">1</span>; i != last; ++i)                   <br>            iter_swap(i, first + (rand() % ((i - first) + <span class="hljs-number">1</span>)));                   <br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i<span class="hljs-string">+1</span>)] * [(i<span class="hljs-string">+1</span>)/(i<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n，（即第i次刚好随<br>机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i<span class="hljs-string">+1</span> （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k<span class="hljs-string">+1</span>)] * <br>[(k<span class="hljs-string">+1</span>)/(k<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。    <br></code></pre></td></tr></table></figure>
<h2 id="2021-11-22-384-打乱数组"><a href="#2021-11-22-384-打乱数组" class="headerlink" title="2021-11-22 384. 打乱数组"></a>2021-11-22 384. 打乱数组</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。<br>实现 Solution class:<br>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num) &#123;<br>        nums = num;<br>    &#125; <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ran = nums;<br>       <span class="hljs-comment">//srand(time(0)); 为什么加了这个会错呢。。。</span><br>       <span class="hljs-comment">// random_shuffle(rand.begin(),rand.end());</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ran.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(index != i) &#123;<br>            <span class="hljs-built_in">swap</span>(ran[index],ran[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ran;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/10/14/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="逻辑位运算符"><a href="#逻辑位运算符" class="headerlink" title="逻辑位运算符"></a>逻辑位运算符</h3><p>&amp; - 位与 100 | 101 = 100<br>| - 位或 100 | 101 = 101<br>^ - 异或 100 | 101 = 001<br>~ - 按位取反  100 = 011</p>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p><code>左移</code>  100 &lt;&lt; 1 = 1000<br><code>右移</code>  100 &gt;&gt; 1 = 10</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="2的幂（简单）"><a href="#2的幂（简单）" class="headerlink" title="2的幂（简单）"></a>2的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-two/">https://leetcode.cn/problems/power-of-two/</a></p>
<p>如果一个数n是2的幂，那么二进制下的样子应该是 10,100,1000……<br>那么n - 1就是 01 011 0111，此时对 n 和 n - 1进行 <code>&amp;</code> 操作<br>按照规则，得到的是 00,000,0000,所以只需要判断 (n &amp; (n - 1))等于0即可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfTwo(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4的幂（简单）"><a href="#4的幂（简单）" class="headerlink" title="4的幂（简单）"></a>4的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-four/">https://leetcode.cn/problems/power-of-four/</a></p>
<p>如果n是4的幂,就代表 4^x == n –&gt;  2^2x == n<br>所以4的幂一定是2的幂，但是2的幂不一定是4的幂，如2^(2x + 1);<br>那么为了区分 2^2x 和 2^(2x + 1),则可以用 mod 3,前者会等于1,后者等于2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfFour(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (n % <span class="hljs-number">3</span>) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><p><a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>如 1011<br>1、 每次&amp;1 然后 右移<br>2、 n = 1011  n - 1 = 1010 所以 n &amp; (n - 1) = 1010 即消去了最后的1,只需重复这个操作</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 方法2</span><br>    <span class="hljs-built_in">int</span> hammingWeight(<span class="hljs-built_in">uint</span>32_t n) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交换数字（中等）"><a href="#交换数字（中等）" class="headerlink" title="交换数字（中等）"></a>交换数字（中等）</h3><p><a href="https://leetcode.cn/problems/swap-numbers-lcci/">https://leetcode.cn/problems/swap-numbers-lcci/</a></p>
<p>要求交换 a, b 且不用临时变量，我懂了，那我直接调函数！<br>漏~ 异或<code>^</code>运算登场<br>    异或的基本操作 a ^ a = 0<br>                   a ^ 0 = a<br>                   a ^ b = b ^ a<br>只需三步：<br>    a = a ^ b; // a = a ^ b<br>    b = a ^ b; // b = (a) ^ b = (展开)(a ^ b) ^ b = a,此时 b = a了<br>    a = a ^ b; // a = (a) ^ (b) = a ^ b ^ a = b；<br>很抽象，但是你细品。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) &#123;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[1]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        return numbers;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字（简单）"><a href="#只出现一次的数字（简单）" class="headerlink" title="只出现一次的数字（简单）"></a>只出现一次的数字（简单）</h3><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<p>异或<code>^</code> : 我又来喽~<br>    基本操作之 – a ^ a = 0<br>直接所有的都异或一遍, 最后得到的就是结果(因为所有的couple都被消了, 独留单身狗)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-II-（中等）"><a href="#只出现一次的数字-II-（中等）" class="headerlink" title="只出现一次的数字 II （中等）"></a>只出现一次的数字 II （中等）</h3><p><a href="https://leetcode.cn/problems/single-number-ii/">https://leetcode.cn/problems/single-number-ii/</a></p>
<p>稍微修改一下, 所有的couple都变成三人行了。不对劲,不对劲,不对劲。<br>没办法异或了, 每个数都是int型, 也就是32位, 那就对所有数的每一位单独处理<br>看一下所有数在某一位上的1的个数<br>                3个 : 代表他们三个是出现了3次的, 单独的那个在这一位上没有信息(1)<br>                4个 ：说明单独的那个在这一位有信息<br>很合理！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>                cnt += (n &gt;&gt; i) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 获取所有数在第i位上1的总数</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">3</span>) &#123;<br>			<span class="hljs-comment">// 1 &lt;&lt; i是左移运算符, 就是把1往左移动i位</span><br>			<span class="hljs-comment">// 1 &lt;&lt; 2 = 100,然后在用 res 进行 | 操作, 就会把res的第i位 变成1</span><br>                res |= (<span class="hljs-number">1</span> &lt;&lt; i); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-III（中等）"><a href="#只出现一次的数字-III（中等）" class="headerlink" title="只出现一次的数字 III（中等）"></a>只出现一次的数字 III（中等）</h3><p><a href="https://leetcode.cn/problems/single-number-iii/">https://leetcode.cn/problems/single-number-iii/</a></p>
<p>这个也能出到3,真的是 无 语 死 啦~~(小潮音)<br>简单来说, 又回到了couple状态, 不过这次是两个单身狗了<br>一遍异或下来的结果是: 狗1 ^ 狗2, 怎么能分开呢？<br>        异或小提示：<br>            a ^ b = 0对于这个题是不可能的, 如果 = 0 他俩就是couple了<br>            a ^ b 的结果中肯定有一位是 1 且 a 和 b 在这一位上还不一样(异或某一位一样的话是 = 0)<br>就用这个把他们区分开来，开码！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		<span class="hljs-comment">// num是所有异或后的结果</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>            num ^= n;<br>        &#125;<br>		<span class="hljs-comment">// dif是最后一个1 如 1010  --&gt;  10</span><br>		<span class="hljs-comment">// 还要确保溢出问题</span><br>        <span class="hljs-keyword">int</span> dif = (num == INT_MIN ? num : num &amp; (-num));<br>        <span class="hljs-keyword">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>			<span class="hljs-comment">// 根据这一位来区分</span><br>            <span class="hljs-keyword">if</span> (n &amp; dif) &#123;<br>                res1 ^= n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res2 ^= n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;res1, res2&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>吐槽一下： 要不是题目要求 <code>必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</code> 我是真想用哈希表啊,我差那点空间吗！！！</p>
<h3 id="汉明距离（简单）"><a href="#汉明距离（简单）" class="headerlink" title="汉明距离（简单）"></a>汉明距离（简单）</h3><p><a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p>
<p>来个简单题休息一下,就是异或然后看1的个数。</p>
<p>复习：<br>    异或 : 相同为0,不同是1<br>    与 : n &amp; (n - 1) 很常用, 消除最后一位1</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-built_in">int</span> hammingDistance(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = x ^ y;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">num</span>) &#123;<br>            <span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span> &amp; (<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交替位二进制数（简单）"><a href="#交替位二进制数（简单）" class="headerlink" title="交替位二进制数（简单）"></a>交替位二进制数（简单）</h3><p><a href="https://leetcode.cn/problems/binary-number-with-alternating-bits/">https://leetcode.cn/problems/binary-number-with-alternating-bits/</a></p>
<p>先转换成二进制,然后挨着判断相邻的一不一样，歪瑞EZ啊</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> hasAlternatingBits(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span> || (n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>位运算</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/10/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">动态规划是一种解决复杂问题的优化技术，它通过将问题分解为子问题并以自底向上的方式求解，最终得到整体问题的最优解。动态规划的核心思想是通过存储和复用之前计算过的结果，避免重复计算以提高效率。<br><br>动态规划的解决过程通常包括以下几个步骤：<br><br>1.确定状态：将原问题拆解成若干子问题，通过定义合适的状态来描述子问题。<br><br>2.定义状态转移方程：根据子问题之间的关系，建立状态转移方程，用于描述问题的最优解与子问题的关系。<br><br>3.定义初始条件：确定最简单的子问题的解，作为初始条件或边界条件。<br><br>4.计算顺序：确定计算子问题的顺序，通常采用自底向上的方式。<br><br>5.储存中间结果：使用数组或其他数据结构来存储中间计算结果，以提高效率。<br><br>6.求解目标问题：根据状态转移方程和初始条件计算出最优解，即整体问题的解。<br><br>动态规划常用于求解具有重叠子问题特性的问题，即原问题的解可以通过子问题的解来计算。它适用于很多领域，例如图论、计算机视觉、自然语言处理等，可以解决一些经典的问题，例如最短路径、背包问题、序列比对等。动态规划能够有效地优化时间复杂度，提供高效的解决方案。<br></code></pre></td></tr></table></figure>

<h2 id="斐波那契类型"><a href="#斐波那契类型" class="headerlink" title="斐波那契类型"></a>斐波那契类型</h2><h3 id="爬楼梯、斐波那契数、第-N-个泰波那契数（简单）"><a href="#爬楼梯、斐波那契数、第-N-个泰波那契数（简单）" class="headerlink" title="爬楼梯、斐波那契数、第 N 个泰波那契数（简单）"></a>爬楼梯、斐波那契数、第 N 个泰波那契数（简单）</h3><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a><br><a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a><br><a href="https://leetcode.cn/problems/n-th-tribonacci-number/">https://leetcode.cn/problems/n-th-tribonacci-number/</a></p>
<p>三个基本差不多的题，贴一个 <code>斐波那契数</code> 的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="使用最小花费爬楼梯（简单）"><a href="#使用最小花费爬楼梯（简单）" class="headerlink" title="使用最小花费爬楼梯（简单）"></a>使用最小花费爬楼梯（简单）</h3><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p><code>状态转移方程</code>: dp[n] = min(dp[n - 1] + cost[n - 1], dp[n - 2] + cost[n - 2])<br><code>初始值设置</code>: dp[0] = 0, dp[1] = 0;<br><code>解释</code>： 可以走1步或2步, 所以从 n 往前推，要么等于 n - 1 的状态加上 n - 1 的 cost, 要么等于 n - 2 的状态加上 n - 2 的 cost</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= cost.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[cost.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="打家劫舍（中等）"><a href="#打家劫舍（中等）" class="headerlink" title="打家劫舍（中等）"></a>打家劫舍（中等）</h3><p><a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
<p><code>状态转移方程 </code> dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);<br><code>初始状态 </code> dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);<br><code>解释 </code> dp[i]代表前i户的最大值。 因为不能选挨着的，所以对于 n 要么选择 n - 2 加上 当前位置的值（即偷当前这户，且保证挨着的前一个没被偷）或 n - 1 （不偷当前这户则等于前一个状态）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="删除并获得点数-（中等）"><a href="#删除并获得点数-（中等）" class="headerlink" title="删除并获得点数 （中等）"></a>删除并获得点数 （中等）</h3><p><a href="https://leetcode.cn/problems/delete-and-earn/description/">https://leetcode.cn/problems/delete-and-earn/description/</a></p>
<p>这个题可以转化成 <code>打家劫舍</code> 同样的道理是选了某一个就不能选它相邻的, 所以想办法把这个题变成打家劫舍<br>方法: 把所有数总和(如 1 2 3 3 3) 记录一下 (1 2 9) 没出现的记作 0, 此时就变成了 <code>打家劫舍</code>。 这里可以优化一下 不用记录数据范围 1 -&gt; 1e4 所有的数, 遍历一遍求出最大值即可</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 直接套用打家劫舍的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; maxVal) &#123;<br>                maxVal = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(maxVal + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cnt[num] += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(cnt);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="不同路径（中等）"><a href="#不同路径（中等）" class="headerlink" title="不同路径（中等）"></a>不同路径（中等）</h3><p><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a><br>不知道为啥挂了个中等 应该属于简单题</p>
<p><code>状态转移方程 </code>  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];<br><code>初始状态 </code> dp[0][n] = 1, dp[m][0] = 1; 起点的同一行或列的路径数肯定是1<br><code>解释 </code> dp[i][j]是结果。 对于每一个(i, j) 只能从 (i - 1, j) | (i, j - 1) 这两个地方到达所以直接相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt; (n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="不同路径-II（中等）"><a href="#不同路径-II（中等）" class="headerlink" title="不同路径 II（中等）"></a>不同路径 II（中等）</h3><p><a href="https://leetcode.cn/problems/unique-paths-ii/">https://leetcode.cn/problems/unique-paths-ii/</a></p>
<p>相比于 I 只是增加了障碍物, 只需要初始化的时候第一行和第一列只要碰到障碍物，其之后的都设置为 0<br>这里有个小坑！(0, 0)这个起点是可能会有障碍物的 这种情况直接返回 0</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>(), n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    dp[i][j] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最小路径和（中等）"><a href="#最小路径和（中等）" class="headerlink" title="最小路径和（中等）"></a>最小路径和（中等）</h3><p><a href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
<p><code>状态转移方程 </code>  dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];<br><code>初始状态 </code> 算一下第一行第一列的前缀和<br><code>解释 </code> 略，跟前一个类似</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;<br>        int m = grid.size(), n = grid<span class="hljs-comment">[0]</span>.size();<br>        if (n == 0 || n == 0) &#123;<br>            return 0;<br>        &#125;<br>        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));<br>        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>;<br>        &#125;<br>        for (int j = 1; j &lt; n; j++) &#123;<br>            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j - 1]</span> + grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span>;<br>        &#125;<br>        for (int i = 1; i &lt; m; i++) &#123;<br>            for (int j = 1; j &lt; n; j++) &#123;<br>                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = min(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>) + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>            &#125;<br>        &#125;<br>        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>滑动窗口（定窗口）</title>
    <url>/2024/08/11/%E7%81%B5%E7%A5%9E%E9%A2%98%E5%8D%95/</url>
    <content><![CDATA[<p>hello</p>
]]></content>
      <categories>
        <category>灵神题单</category>
      </categories>
  </entry>
</search>
