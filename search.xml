<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/11/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/img/Lambda.png" alt="lena"></p>
<h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表[]"></a>捕获列表[]</h2><p>捕获列表是零或多个捕获符的逗号分隔符列表，可选地以默认捕获符开始（仅有的默认捕获符是 &amp; 和 = ）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ ]</span>。空捕获列表，lambda不能使用所在函数中的变量。<br><span class="hljs-selector-attr">[=]</span>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。<br><span class="hljs-selector-attr">[&amp;]</span>。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。<br><span class="hljs-selector-attr">[this]</span>。函数体内可以使用Lambda所在类中的成员变量。<br><span class="hljs-selector-attr">[a]</span>。将<span class="hljs-selector-tag">a</span>按值进行传递。按值进行传递时，函数体内不能修改传递进来的<span class="hljs-selector-tag">a</span>的拷贝，因为默认情况下函数是const的。要修改传递进来的<span class="hljs-selector-tag">a</span>的拷贝，可以添加mutable修饰符。<br><span class="hljs-selector-attr">[&amp;a]</span>。将<span class="hljs-selector-tag">a</span>按引用进行传递。<br><span class="hljs-selector-attr">[=，&amp;a, &amp;b]</span>。除<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>按引用进行传递外，其他参数都按值进行传递。<br><span class="hljs-selector-attr">[&amp;, a, b]</span>。除<span class="hljs-selector-tag">a</span>和<span class="hljs-selector-tag">b</span>按值进行传递外，其他参数都按引用进行传递。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++知识</category>
      </categories>
  </entry>
  <entry>
    <title>4.9-力扣-780到达终点(困难)</title>
    <url>/2022/04/09/4-9-%E5%8A%9B%E6%89%A3-780%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9-%E5%9B%B0%E9%9A%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。<br>从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过要求可以看出 (x,y) -&gt; (x, x + y) 或者 (x + y, y);那么可以反推得<br>(tx,ty) 的前身一定是(tx - a, ty) 或者(tx, ty - a) 其中a是上一层的tx或者ty;<br>以测试用例1来说明</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">示例 <span class="hljs-number">1</span>:<br>输入: sx = <span class="hljs-number">1</span>, sy = <span class="hljs-number">1</span>, tx = <span class="hljs-number">3</span>, ty = <span class="hljs-number">5</span><br>输出: <span class="hljs-literal">true</span><br>解释:<br>可以通过以下一系列转换从起点转换到终点：<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span> -&gt;</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)</span> -&gt;</span> (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">tx		ty<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span><br>.		.<br>.		.<br><span class="hljs-number">3</span>		<span class="hljs-number">5</span> <span class="hljs-comment">% 3 //因为这里可以加相同的tx无数次来达到ty</span><br>.		.<br>.		.<br><span class="hljs-number">3</span> <span class="hljs-comment">% 2	2//同理 此时已经有了一边和sx 或者 sy相等，也就是从二元变成了一元，只需判断能否除余得0即可</span><br>[注]一定是大的除余小的，原因很简单......<br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">reachingPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sx, <span class="hljs-keyword">int</span> sy, <span class="hljs-keyword">int</span> tx, <span class="hljs-keyword">int</span> ty)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tx &lt; sx || ty &lt; sy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (tx &gt; ty) &#123;<br>            <span class="hljs-keyword">if</span> (sy == ty)    <br>                <span class="hljs-keyword">return</span> sx &gt;= (tx % ty) &amp;&amp; (tx - sx) % sy == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx % ty, ty);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tx &lt; ty)&#123;<br>            <span class="hljs-keyword">if</span> (sx == tx)    <br>                <span class="hljs-keyword">return</span> sy &gt;= (ty % tx) &amp;&amp; (ty - sy) % sx == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reachingPoints</span>(sx, sy, tx, ty % tx);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> tx == sx &amp;&amp; ty == sy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/2021/10/26/%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="17电话号码的字母组合"><a href="#17电话号码的字母组合" class="headerlink" title="17电话号码的字母组合"></a>17电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。(九键输入法)</p>
<p>思路：九宫格每个数字（2-9）分别对应相应的字母 很显然要用哈希表将他们联系起来</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>          &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>          &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>      &#125;;<br></code></pre></td></tr></table></figure>
<p>因为是要求出所有的可能，首先想到的就是递归,回溯,dfs.代码分为两块</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span> == <span class="hljs-built_in">digits</span>.<span class="hljs-built_in">size</span>()) &#123;<br>          res.push_back(tmp);<br>      &#125; //长度够了后返回结果<br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">char digit = digits[index]; <span class="hljs-regexp">//</span>输入数字的索引<br>string letters = pair[digit];<span class="hljs-regexp">//</span>输入数字对应的字母的字符串<br><span class="hljs-keyword">for</span>(auto l : letters) &#123; <span class="hljs-regexp">//</span>对每一个遍历<br>    tmp.push_back(l);<span class="hljs-regexp">//</span>tmp数组push <span class="hljs-string">&#x27;l&#x27;</span><br>    dfs(pair,index + <span class="hljs-number">1</span>,digits); <span class="hljs-regexp">//</span>递归 index++表示着要和下一个数字匹配<br>    tmp.pop_back();<span class="hljs-regexp">//</span>回溯（关键） 有点类似于树<br>&#125; <span class="hljs-regexp">//</span>处理过程<br></code></pre></td></tr></table></figure>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair &#123;<br>            &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(pair,<span class="hljs-number">0</span>,digits);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-keyword">char</span>,string&gt; pair,<span class="hljs-keyword">int</span> index,string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">char</span> digit = digits[index];<br>        string letters = pair[digit];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : letters) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(l);<br>            <span class="hljs-built_in">dfs</span>(pair,index + <span class="hljs-number">1</span>,digits);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22括号生成"><a href="#22括号生成" class="headerlink" title="22括号生成"></a>22括号生成</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。<br>有效括号组合需满足：左括号必须以正确的顺序闭合。</p>
<p>思路:有了上一个题的经验,但是这个没有什么需要处理的，直接进入dfs环节（因为只有左右括号一说）<br>还是分为两块</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(tmp.size() == n * <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.push_back</span>(tmp);<br>      &#125;<span class="hljs-comment">//因为是左右括号，每添加一次就会++ 而给的n代表的是括号对数</span><br></code></pre></td></tr></table></figure>
<p>然后又到了如何处理和回溯阶段</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">		<span class="hljs-selector-tag">if</span>(left &lt; n) &#123;<span class="hljs-comment">//首先只要左括号数小于n 一直加左括号 直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125;<br>        <span class="hljs-selector-tag">if</span>(right &lt; left) &#123;<span class="hljs-comment">//直到不能加了就开始加有括号</span><br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-selector-tag">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            <span class="hljs-selector-tag">tmp</span><span class="hljs-selector-class">.pop_back</span>();<br>        &#125; <span class="hljs-comment">//同样这两个都是用pop_back进行回溯</span><br><span class="hljs-comment">//过程大概就是 左括号三个 对应的右括号的情况 然后两个左括号在对应有括号（右括号必须小于左括号）</span><br></code></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left &lt; n) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n,left + <span class="hljs-number">1</span>, right);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; left) &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-built_in">dfs</span>(n, left, right + <span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    string tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="37解数独"><a href="#37解数独" class="headerlink" title="37解数独"></a>37解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 遵循如下规则：<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>思路：乍一看这个题是困难题,而且貌似非常复杂,其实也要遵循“标准”步骤<br>同样的道理,没有需要处理的就直接进入dfs</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//因为这个的停止条件就是遍历完全部，所以省去第一步 直接到如何处理和回溯</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-comment">//双层for找到需要判断的&quot;格子&quot;</span><br>               <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//不是空格就继续</span><br>               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123; <span class="hljs-comment">//假如是空格，这里有点类似第一个的 &#x27;2&#x27;代表 &quot;abc&quot; 这里的空格代表 0 - 9</span><br>                   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<span class="hljs-comment">//这里是题目的条件，要求填入的数合法,在回溯问题中可视为已知，这就可以类比为普通的dfs问题</span><br>                       board[i][j] = ch;<span class="hljs-comment">//填上相应数字</span><br>                       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//递归，如果最后返回true就说明有解</span><br>                       board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//回溯 </span><br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>判断的函数也是非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>               <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(board);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;1&#x27;</span>; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ch++) &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isvalid</span>(i,j,ch,board)) &#123;<br>                        board[i][j] = ch;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col,<span class="hljs-keyword">char</span> ch,vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(board[i][col] == ch) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> m = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> n = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == ch) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dfs回溯</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>对象创建限制在堆或栈</title>
    <url>/2021/11/25/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%99%90%E5%88%B6%E5%9C%A8%E5%A0%86%E6%88%96%E6%A0%88/</url>
    <content><![CDATA[<p>如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>C++ 中的类的对象的建立分为两种：静态建立、动态建立。<br>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;<br>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A();</p>
<span id="more"></span>
<h2 id="限制对象只能建立在堆上"><a href="#限制对象只能建立在堆上" class="headerlink" title="限制对象只能建立在堆上"></a>限制对象只能建立在堆上</h2><h3 id="最直观的思想：避免直接调用类的构造函数"><a href="#最直观的思想：避免直接调用类的构造函数" class="headerlink" title="最直观的思想：避免直接调用类的构造函数"></a>最直观的思想：避免直接调用类的构造函数</h3><p>因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
<h3 id="解决方法-1："><a href="#解决方法-1：" class="headerlink" title="解决方法 1："></a>解决方法 1：</h3><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">public</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">destory</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br><span class="hljs-attr">private</span>:<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>该方法存在的问题：<br>用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
<h3 id="解决方法-2："><a href="#解决方法-2：" class="headerlink" title="解决方法 2："></a>解决方法 2：</h3><p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">protected</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br><br><span class="hljs-attr">public</span>:<br>    <span class="hljs-keyword">static</span> A *<span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">destory</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="限制对象只能建立在栈上"><a href="#限制对象只能建立在栈上" class="headerlink" title="限制对象只能建立在栈上"></a>限制对象只能建立在栈上</h2><p>解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-attr">private</span>:<br>    <span class="hljs-keyword">void</span> *operator <span class="hljs-function"><span class="hljs-title">new</span>(<span class="hljs-params">size_t t</span>)</span> &#123;&#125;    <span class="hljs-comment">// 注意函数的第一个参数和返回值都是固定的</span><br>    <span class="hljs-keyword">void</span> operator <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ptr</span>)</span> &#123;&#125; <span class="hljs-comment">// 重载了 new 就需要重载 delete</span><br><span class="hljs-attr">public</span>:<br>    <span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>    ~<span class="hljs-function"><span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>C++知识</category>
      </categories>
  </entry>
  <entry>
    <title>edge扩展</title>
    <url>/2022/07/26/edge%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="edge不能下载扩展的解决方法"><a href="#edge不能下载扩展的解决方法" class="headerlink" title="edge不能下载扩展的解决方法"></a>edge不能下载扩展的解决方法</h2><h3 id="1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com"><a href="#1-https-ping-chinaz-com-msedgeextensions-sf-tlu-dl-delivery-mp-microsoft-com" class="headerlink" title="1- https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com"></a>1- <a href="https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com">https://ping.chinaz.com/msedgeextensions.sf.tlu.dl.delivery.mp.microsoft.com</a></h3><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">打开此网站，选择延迟较低<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure>
<h3 id="2-C-Windows-System32-drivers-etc"><a href="#2-C-Windows-System32-drivers-etc" class="headerlink" title="2- C:\Windows\System32\drivers\etc"></a>2- C:\Windows\System32\drivers\etc</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">找到此路径下的hosts文件，在最先面添加 <br><span class="hljs-number">116.55</span>.<span class="hljs-number">252.94</span> msedgeextensions<span class="hljs-selector-class">.sf</span><span class="hljs-selector-class">.tlu</span><span class="hljs-selector-class">.dl</span><span class="hljs-selector-class">.delivery</span><span class="hljs-selector-class">.mp</span><span class="hljs-selector-class">.microsoft</span><span class="hljs-selector-class">.com</span> #Edge商店扩展<br><span class="hljs-selector-attr">[注]</span>前面为复制的ip 后面是商店扩展的url，如果别的有问题也可以替换为别的<br></code></pre></td></tr></table></figure>
<h3 id="3-管理员身份打开cmd-输入-ipconfig-flushdns"><a href="#3-管理员身份打开cmd-输入-ipconfig-flushdns" class="headerlink" title="3- 管理员身份打开cmd 输入 ipconfig /flushdns"></a>3- 管理员身份打开cmd 输入 ipconfig /flushdns</h3><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">客户端查询DNS的过程是：<br><br>本地host文件—本地缓存—-DNS服务器<br><br>Ｈost文件用于本地DNS解析，并且优先于寻找网络上的DNS服务器<br><br>在Windows中，它的目录通常在[Windows目录]\system32\drivers\etc\下。<br><br><span class="hljs-symbol">Hosts</span>文件是一个纯文本文件，用记事本就可以将其打开。这个文件是根据TCP/<span class="hljs-built_in">IP</span> for Windows 的标准来工作的，它的作用是包含<span class="hljs-built_in">IP</span>地址和Host name(主机名)的映射关系，每段只能包括一个映射关系，<span class="hljs-built_in">IP</span>地址要放在每段的最前面，后面写Host name(主机名)，中间加个空格。如：<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> localhost.<br><br>我们知道，当电脑访问网站时，首先通过DNS服务器把网络 域名解析成<span class="hljs-built_in">IP</span>地址后，我们的计算机才能访问。如果每个域名请求都要等待域名服务器解析后返回<span class="hljs-built_in">IP</span>，访问速度就会比较慢，而Hosts文件正可以解决这个 问题。在进行DNS请求以前，Windows系统会先检查Hosts文件中是否有这个地址映射关系，如果有则调用这个<span class="hljs-built_in">IP</span>地址映射，如果没有再向DNS服 务器提出域名解析。<br><br>对于要经常访问的网站和用于测试服务，我们可以通过在Hosts中配置域名和<span class="hljs-built_in">IP</span>的映射关系，这样当我们输入域名计算机就能很快解析出<span class="hljs-built_in">IP</span>，而不用请求网络上的DNS服务器。<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/11/15/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="第-267-场周赛-5929-处理含限制条件的好友请求"><a href="#第-267-场周赛-5929-处理含限制条件的好友请求" class="headerlink" title="第 267 场周赛 5929. 处理含限制条件的好友请求"></a>第 267 场周赛 5929. 处理含限制条件的好友请求</h2><p>给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。<br>给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。<br>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。<br>如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。<br>一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。<br>返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。<br>注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p>
<span id="more"></span>
<h2 id="并查集模板"><a href="#并查集模板" class="headerlink" title="并查集模板"></a>并查集模板</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; size;<br>    <span class="hljs-keyword">int</span> n;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">parent</span>(_n), <span class="hljs-built_in">size</span>(_n, <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">iota</span>(parent.<span class="hljs-built_in">begin</span>(), parent.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<span class="hljs-comment">//给parent累加赋值 0,1,2......</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">//找到x的最高树节点</span><br>        <span class="hljs-keyword">return</span> parent[x] == x ? x : parent[x] = <span class="hljs-built_in">findset</span>(parent[x]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//成为朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<span class="hljs-comment">//已经是就不用操作</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size[x] &lt; size[y]) &#123;并查集，维护树高，把矮的往高的合并再加上路径优化可以得到最优的复杂度<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        &#125;<br>        parent[y] = x;<br>        size[x] += size[y];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<span class="hljs-comment">//判断是否是朋友</span><br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="题目实现代码-注释"><a href="#题目实现代码-注释" class="headerlink" title="题目实现代码 + 注释"></a>题目实现代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">friendRequests</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; re, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; qu)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt; res;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//初始化并查集类 并且赋初值n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; qu.<span class="hljs-built_in">size</span>(); ++i)&#123;<span class="hljs-comment">//遍历每一个成为朋友的请求request</span><br>            <span class="hljs-keyword">int</span> x = qu[i][<span class="hljs-number">0</span>], y = qu[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// x,y分别获取值</span><br>            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">true</span>;<span class="hljs-comment">//用于判断能否成为朋友，即是否被限制（restrictions）</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">connected</span>(x, y))&#123;<span class="hljs-comment">//如果不满足这个条件说明两个人已经是朋友，就不用了进行判断，直接push_back</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; re.<span class="hljs-built_in">size</span>(); ++j)&#123;<span class="hljs-comment">//如果满足就对每一条限制(resstriction)进行判断</span><br>                    <span class="hljs-keyword">int</span> p = re[j][<span class="hljs-number">0</span>], q = re[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>((uf.<span class="hljs-built_in">connected</span>(p, x) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, y))<br>                      || (uf.<span class="hljs-built_in">connected</span>(p, y) &amp;&amp; uf.<span class="hljs-built_in">connected</span>(q, x)))&#123;<span class="hljs-comment">//限制条件 P-X &amp;&amp; Q-Y则 X-Y不能成立</span><br>                        f = <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果存在一种不能成立的 就让f = false 代表不能成为朋友</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(f)&#123; <span class="hljs-comment">//true就 unite(让两个成为朋友) push_back true;</span><br>                uf.<span class="hljs-built_in">unite</span>(x, y);<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//否则就 push_back false;</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>最小堆（优先队列 priority_queue）</title>
    <url>/2021/11/03/%E6%9C%80%E5%B0%8F%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%20priority_queue%EF%BC%89/</url>
    <content><![CDATA[<h2 id="11-03-407-接雨水-II"><a href="#11-03-407-接雨水-II" class="headerlink" title="11-03 407. 接雨水 II"></a>11-03 407. 接雨水 II</h2><p>给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>
<p>根据木桶原理，接到的雨水的高度由这个容器周围最短的木板来确定的。我们可以知道容器内水的高度取决于最外层高度最低的方块，如图所示：<br><img src="/img/P1.png" alt="来自LeetCode"><br>我们假设已经知道最外层的方块接水后的高度的最小值，则此时我们根据木桶原理，肯定可以确定最小高度方块的相邻方块的接水高度。<br>我们同时更新外层的方块标记，我们在新的最外层的方块再次找到接水后的高度的最小值，同时确定与其相邻的方块的接水高度，如图所示:<br><img src="/img/P2.png" alt="来自LeetCode"><br>然后再次更新最外层，依次迭代直到求出所有的方块的接水高度，即可知道矩阵中的接水容量。 这里使用到了一种数据结构—最小堆</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆也叫优先队列，堆是一种特殊的完全二叉树数据结<br>堆分为两种，最大堆，最小堆。<br>最大堆：根节点大于左右两个子节点的完全二叉树<br>最小堆：根节点小于左右两个子节点的完全二叉树<br>堆可以用数组来存储，<br>a[i]处存根节点，a[2 * i]存左子树的根节点 ; a[2 * i + 1]存右子树的根节点。i从1开始!!<br><img src="/img/P3.png" alt="完全二叉树"></p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>C++ STL实现的优先级队列是一种容器适配器，类似堆，可以随时插入元素，但只能检索到优先级队列中优先级最高的元素。<br>priority_queue&lt;int,vector,less&gt; q;最大堆（默认为最大堆）<br>priority_queue&lt;int,vector,greater&gt; q;最小堆</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; small_heap; <span class="hljs-comment">//最小堆定义方法</span><br>第一个参数T：元素（element）类型<br>第二个参数Container：必须是容器类型Container，用来存储元素（element），其类型必须是第一个参数<br>第三个参数Compare：比较形式，默认是less<br><br>q.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回q里元素个数</span><br>q.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//返回q是否为空，空则返回1，否则返回0</span><br>q.<span class="hljs-built_in">push</span>(k);<span class="hljs-comment">//在q的末尾插入k</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删掉q的第一个元素</span><br>q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回q的第一个元素</span><br></code></pre></td></tr></table></figure>

<h2 id="完整代码-详细注释"><a href="#完整代码-详细注释" class="headerlink" title="完整代码 + 详细注释"></a>完整代码 + 详细注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trapRainWater</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> row = heightMap.<span class="hljs-built_in">size</span>(), col = heightMap[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">3</span> || col &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//不足 3X3不可能接到水</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; minHeap;<span class="hljs-comment">//最小堆定义，</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == row - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == col - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//最外围一圈不可能接到水，先入队列</span><br>                    minHeap.<span class="hljs-built_in">push</span>(&#123;heightMap[i][j], i * col + j&#125;);<span class="hljs-comment">//i * col + j以这种方式存储</span><br>                    vis[i][j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//vis数组来记录访问</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; direction =  &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向--左、上、右、下</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; tmp = minHeap.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//定义一个临时变量获取队列top()值</span><br>            minHeap.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队列</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123; <span class="hljs-comment">//四个方向分别遍历</span><br>                <span class="hljs-keyword">int</span> nextrow = tmp.second / col + direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> nextcol = tmp.second % col + direction[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//下一个的坐标 i，j值，承接上面的存储方法</span><br><br>            <span class="hljs-keyword">if</span>(nextrow &gt;= <span class="hljs-number">0</span> &amp;&amp; nextrow &lt; row &amp;&amp; nextcol &gt;= <span class="hljs-number">0</span> &amp;&amp; nextcol &lt; col &amp;&amp; !vis[nextrow][nextcol]) &#123; <span class="hljs-comment">//首先得在范围内 并且未被访问</span><br>                    <span class="hljs-keyword">if</span>(heightMap[nextrow][nextcol] &lt; tmp.first) &#123; <span class="hljs-comment">//最小堆的特性，最小值，如果符合条件就说明存在“木桶” </span><br>                        res += tmp.first - heightMap[nextrow][nextcol];<span class="hljs-comment">//结果加上</span><br>                    &#125;<br>                vis[nextrow][nextcol] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//代表已经访问</span><br>                minHeap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">max</span>(heightMap[nextrow][nextcol], tmp.first), nextrow * col + nextcol&#125;);<span class="hljs-comment">//访问后放入最小堆</span><br>                &#125;<br>            &#125;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>洗牌算法-随机打乱数组</title>
    <url>/2021/11/22/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95-%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Inside-Out-Algorithm"><a href="#Inside-Out-Algorithm" class="headerlink" title="Inside-Out Algorithm"></a>Inside-Out Algorithm</h2><p>Inside-Out Algorithm 算法的基本思路是从前向后扫描数据，把位置i的数据随机插入到前i个（包括第i个）位置中（假设为k）<br>这个操作是在新数组中进行，然后把原始数据中位置k的数字替换新数组位置i的数字。其实效果相当于新数组中位置k和位置i的数字进行交互。</p>
<span id="more"></span>
<h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">RandomAccessIterator</span>&gt;                                             <br><span class="hljs-symbol">inline</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">random_shuffle</span>(<span class="hljs-symbol">RandomAccessIterator</span> <span class="hljs-symbol">first, <span class="hljs-symbol">RandomAccessIterator</span></span> <span class="hljs-symbol">last</span>) &#123; <br>    <span class="hljs-keyword">if</span>(first != last)                                                             <br>        <span class="hljs-keyword">for</span>(RandomAccessIterator i = first + <span class="hljs-number">1</span>; i != last; ++i)                   <br>            iter_swap(i, first + (rand() % ((i - first) + <span class="hljs-number">1</span>)));                   <br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">原数组的第 i 个元素（随机到的数）在新数组的前 i 个位置的概率都是：(1/i) * [i/(i<span class="hljs-string">+1</span>)] * [(i<span class="hljs-string">+1</span>)/(i<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n，（即第i次刚好随<br>机放到了该位置，在后面的n-i 次选择中该数字不被选中）。<br>原数组的第 i 个元素（随机到的数）在新数组的 i<span class="hljs-string">+1</span> （包括i + 1）以后的位置（假设是第k个位置）的概率是：(1/k) * [k/(k<span class="hljs-string">+1</span>)] * <br>[(k<span class="hljs-string">+1</span>)/(k<span class="hljs-string">+2</span>)] *...* [(n<span class="hljs-string">-1</span>)/n] = 1/n（即第k次刚好随机放到了该位置，在后面的n-k次选择中该数字不被选中）。    <br></code></pre></td></tr></table></figure>
<h2 id="2021-11-22-384-打乱数组"><a href="#2021-11-22-384-打乱数组" class="headerlink" title="2021-11-22 384. 打乱数组"></a>2021-11-22 384. 打乱数组</h2><p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。<br>实现 Solution class:<br>Solution(int[] nums) 使用整数数组 nums 初始化对象<br>int[] reset() 重设数组到它的初始状态并返回<br>int[] shuffle() 返回数组随机打乱后的结果</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num) &#123;<br>        nums = num;<br>    &#125; <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ran = nums;<br>       <span class="hljs-comment">//srand(time(0)); 为什么加了这个会错呢。。。</span><br>       <span class="hljs-comment">// random_shuffle(rand.begin(),rand.end());</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ran.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(index != i) &#123;<br>            <span class="hljs-built_in">swap</span>(ran[index],ran[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ran;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>洗牌算法</tag>
      </tags>
  </entry>
  <entry>
    <title>植物大战僵尸开发日记（1）</title>
    <url>/2023/01/10/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>《植物大战僵尸》是由美国宝开游戏公司(PopCap Games)开发的一款益智策略类塔防御战游戏，也是《植物大战僵尸》系列的第一部作品。于2009年5月5日发售。</p>
<h2 id="开发软件"><a href="#开发软件" class="headerlink" title="开发软件"></a>开发软件</h2><p>Unity 2020.3.43f1c1 (64-bit)</p>
<h2 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h2><p>C#</p>
<h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><p><a href="https://www.bilibili.com/video/BV1FA411j7ug?p=1&amp;vd_source=0ac943c9b293c8cf36d2dc3204b8d82d">https://www.bilibili.com/video/BV1FA411j7ug?p=1&amp;vd_source=0ac943c9b293c8cf36d2dc3204b8d82d</a></p>
<h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><p>链接：<a href="https://pan.baidu.com/s/1RKTgqLtwanYQq7iLyXc5gg">https://pan.baidu.com/s/1RKTgqLtwanYQq7iLyXc5gg</a><br>提取码：l4po</p>
<h2 id="1-游戏场景搭建"><a href="#1-游戏场景搭建" class="headerlink" title="1.游戏场景搭建"></a>1.游戏场景搭建</h2><p><img src="/img/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/1-1.png" alt="图1-1 植物卡槽"></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">MainPanel:</span>植物卡槽<br><span class="hljs-symbol">Group:</span>植物卡片集合可自由拉伸<br>image：植物(如向日葵)<br><span class="hljs-symbol">Text:</span>植物价格文本<br><span class="hljs-symbol">SunNumText:</span>总阳光数文本<br></code></pre></td></tr></table></figure>
<p><img src="/img/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/1-2.png" alt="图1-2 Group分组配置"></p>
<h2 id="2-天空中阳光的生成和下落和点击"><a href="#2-天空中阳光的生成和下落和点击" class="headerlink" title="2.天空中阳光的生成和下落和点击"></a>2.天空中阳光的生成和下落和点击</h2><p><img src="/img/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/2-1.png" alt="图2-1 文件夹的创建"></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Animations:</span>动画<br>	Controll动画控制器<br><span class="hljs-symbol">Resources:</span><br><span class="hljs-symbol">Scripts:</span>C<span class="hljs-meta">#脚本</span><br></code></pre></td></tr></table></figure>
<p>创建物体SkySunManager来管理天空中的阳光，并添加上C#脚本(同名)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br><br>public <span class="hljs-keyword">class</span> SkySunManager : MonoBehaviour<br>&#123;<br>    <span class="hljs-comment">//阳光预制体(Unity 的 GameObject 类用于表示任何可以存在于场景中的事物。)</span><br>    <span class="hljs-keyword">private</span> GameObject Prefab_sun;<br>    <span class="hljs-comment">//固定生成时Y轴坐标在背景上方合适位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> createSunPosY = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">//生成阳光时的X轴范围</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> createSunMaxPosX = <span class="hljs-number">5.3</span>f;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> createSunMinPosX = -<span class="hljs-number">5.3</span>f;<br>    <span class="hljs-comment">//阳光下落位置的Y轴范围</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> sunDownMaxPosY = <span class="hljs-number">3</span>f;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> sunDownMinPosY = -<span class="hljs-number">4</span>f;<br>    void <span class="hljs-constructor">Start()</span><br>    &#123;<br>		<span class="hljs-comment">//让其等于Resources文件夹下的Sun物体</span><br>        Prefab_sun = Resources.Load&lt;GameObject&gt;(<span class="hljs-string">&quot;Sun&quot;</span>);<br>		<span class="hljs-comment">//void InvokeRepeating(string methodName,float time,float delayTime)：等待time之后，再调用方法methodName方法，并且每隔delayTime再去调用methodName方法。</span><br>        <span class="hljs-constructor">InvokeRepeating(<span class="hljs-string">&quot;createSun&quot;</span>, 3, 3)</span>;<br>    &#125;<br><br>    <br>    void <span class="hljs-constructor">Update()</span><br>    &#123;<br>        <br>    &#125;<br>    <span class="hljs-comment">//生成阳光</span><br>    void create<span class="hljs-constructor">Sun()</span> &#123;<br>		<span class="hljs-comment">//阳光实例化 ！！！</span><br>        Sun sun = GameObject.Instantiate&lt;GameObject&gt;(Prefab_sun, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vector3</span>.</span></span>zero, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Quaternion</span>.</span></span>identity,transform).GetComponent&lt;Sun&gt;<span class="hljs-literal">()</span>;<br>		<span class="hljs-comment">//随机生成X,Y坐标</span><br>        <span class="hljs-built_in">float</span> createX = Random.<span class="hljs-constructor">Range(<span class="hljs-params">createSunMinPosX</span>, <span class="hljs-params">createSunMaxPosX</span>)</span>;<br>        <span class="hljs-built_in">float</span> DownY = Random.<span class="hljs-constructor">Range(<span class="hljs-params">sunDownMinPosY</span>, <span class="hljs-params">sunDownMaxPosY</span>)</span>;<br>		<span class="hljs-comment">//下落最终位置  生成时X坐标  生成时的Y坐标(固定)</span><br>        sun.<span class="hljs-constructor">InitForSky(DownY, <span class="hljs-params">createX</span>, <span class="hljs-params">createSunPosY</span>)</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>为Sun物体创建脚本</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sun</span> :</span> MonoBehaviour<br>&#123;<br>    <span class="hljs-comment">//下落的目标点Y</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> DownTargetPosY;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (transform.position.y &lt;= DownTargetPosY) &#123;<br>            <span class="hljs-built_in">Invoke</span>(<span class="hljs-string">&quot;DestorySun&quot;</span>, <span class="hljs-number">5</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        transform.<span class="hljs-built_in">Translate</span>(Vector3.down * Time.deltaTime);<br>    &#125;<br>    <span class="hljs-comment">//鼠标点击阳光时增加阳光数量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        GameManager.Instance.SunNum += <span class="hljs-number">50</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestorySun</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">Destroy</span>(gameObject);<br>    &#125;<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitForSky</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DownTargetPosY,<span class="hljs-keyword">float</span> createPosX, <span class="hljs-keyword">float</span> createPosY)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.DownTargetPosY = DownTargetPosY;<br>        transform.position = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector2</span>(createPosX, createPosY);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="2023年1月10日20-35-34-未完……"><a href="#2023年1月10日20-35-34-未完……" class="headerlink" title="2023年1月10日20:35:34  未完……"></a>2023年1月10日20:35:34  未完……</h2>]]></content>
      <categories>
        <category>植物大战僵尸</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-2488</title>
    <url>/2023/03/06/POJ-2488/</url>
    <content><![CDATA[<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">35</span>;<br><span class="hljs-keyword">int</span> vis[N][N];<br><span class="hljs-keyword">int</span> p, q ,flag;<br><span class="hljs-keyword">char</span> res[<span class="hljs-number">1000</span>];<br><span class="hljs-comment">//要求字典序 所以</span><br><span class="hljs-comment">//     A B C</span><br><span class="hljs-comment">//   1 。。。       优先-y 让字母更靠近A</span><br><span class="hljs-comment">//   2 。。。       其次-x 让数字更靠近1</span><br><span class="hljs-comment">//   3 。。。</span><br><br><span class="hljs-comment">//Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. </span><br><span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br>    <span class="hljs-comment">//最终状态 走遍所有格子</span><br>    <span class="hljs-keyword">if</span> (cnt == p * q) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A1&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">2</span> * cnt; i++) &#123;<br>            cout &lt;&lt; res[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>        flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//此处改变</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> &amp;&amp; !flag; i++) &#123;<br>        <span class="hljs-keyword">int</span> tx = x + dir[i][<span class="hljs-number">0</span>], ty = y + dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//不在范围内</span><br>        <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">1</span> || tx &gt; p || ty &lt; <span class="hljs-number">1</span> || ty &gt; q) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//没访问过</span><br>        <span class="hljs-keyword">if</span> (!vis[tx][ty]) &#123;<br>            vis[tx][ty] = <span class="hljs-number">1</span>;<br>            res[<span class="hljs-number">2</span> * cnt] = <span class="hljs-string">&#x27;A&#x27;</span> + ty - <span class="hljs-number">1</span>;<br>            res[<span class="hljs-number">2</span> * cnt + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span> + tx - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">dfs</span>(tx, ty, cnt + <span class="hljs-number">1</span>);<br>            vis[tx][ty] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯</span><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t, ca = <span class="hljs-number">0</span>;<span class="hljs-comment">//输入次数 ， 结果的序号</span><br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; p &gt;&gt; q;<span class="hljs-comment">// row col</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Scenario #i&quot;</span> &lt;&lt; ++ca &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<span class="hljs-comment">//给vis赋值为0</span><br>        flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前状态，dfs会改变flag，如果没改变说明没有找到结果</span><br>        vis[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//初始第一个点为已经经过 </span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#1:</span><br><span class="hljs-built_in">A1</span><br><br><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#2:</span><br>impossible<br><br><span class="hljs-keyword">Scenario </span><span class="hljs-comment">#3:</span><br>A<span class="hljs-symbol">1B</span>3C1A<span class="hljs-symbol">2B</span>4C2A<span class="hljs-symbol">3B</span>1C3A<span class="hljs-symbol">4B</span>2C4<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-2488"><a href="#http-poj-org-problem-id-2488" class="headerlink" title="http://poj.org/problem?id=2488"></a><a href="http://poj.org/problem?id=2488">http://poj.org/problem?id=2488</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3009</title>
    <url>/2023/03/08/POJ-3009/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.可以往任意方向走 但是不碰到障碍物不会停下<br>2.碰到障碍物（石头）就会把石头撞碎 -&gt; 从1变成0<br>3.默认规定 终点位置摩擦力极大 即到终点就会停。</p>
<span id="more"></span>
<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">#<span class="hljs-keyword">include</span>&lt;iostream&gt;<br>using namespace std;<br><br>int square[30][30];<br>int min_steps;<br>int w, <span class="hljs-keyword">h</span>;<br>int sx, sy;<br>int <span class="hljs-keyword">dir</span>[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;;<br>void dfs(int x, int y, int cnt) &#123;<br>    <span class="hljs-comment">//You cannot throw the stone more than 10 times in a game.If the stone does not reach the goal in 10 moves, the game ends in failure.</span><br>    <span class="hljs-keyword">if</span> (cnt &gt;= 10) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (int i = 0; i &lt; 4; i++) &#123;<br>        int tx = x + <span class="hljs-keyword">dir</span>[i][0];<br>        int <span class="hljs-keyword">ty</span> = y + <span class="hljs-keyword">dir</span>[i][1];<br>        int flag = 1, tag = 0;<br>        <span class="hljs-comment">//Once the stone begins to move, it will proceed until it hits a block.</span><br>        <span class="hljs-keyword">while</span> (1) &#123;<br>            <span class="hljs-comment">//越界</span><br>            <span class="hljs-keyword">if</span> (tx &lt; 1 || tx &gt; <span class="hljs-keyword">h</span> || <span class="hljs-keyword">ty</span> &lt; 1 || <span class="hljs-keyword">ty</span> &gt; w) &#123;<br>                flag = 0;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//碰到石头</span><br>            <span class="hljs-keyword">if</span> (square[tx][<span class="hljs-keyword">ty</span>] == 1) &#123;<br>                tag = 1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//到达终点</span><br>            <span class="hljs-keyword">if</span> (square[tx][<span class="hljs-keyword">ty</span>] == 3 &amp;&amp; min_steps &gt; ++cnt) &#123;<br>                min_steps = cnt;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//一直移动</span><br>            tx += <span class="hljs-keyword">dir</span>[i][0];<br>            <span class="hljs-keyword">ty</span> += <span class="hljs-keyword">dir</span>[i][1];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//越界则换方向</span><br>        <span class="hljs-keyword">if</span> (tag) &#123;<br>            square[tx][<span class="hljs-keyword">ty</span>] = 0;<br>            <span class="hljs-comment">//You may throw it to any direction unless it is blocked immediately</span><br>            tx -= <span class="hljs-keyword">dir</span>[i][0];<br>            <span class="hljs-keyword">ty</span> -= <span class="hljs-keyword">dir</span>[i][1];<br>            <span class="hljs-keyword">if</span> (tx == x &amp;&amp; <span class="hljs-keyword">ty</span> == y) &#123;<br>                square[tx + <span class="hljs-keyword">dir</span>[i][0]][<span class="hljs-keyword">ty</span> + <span class="hljs-keyword">dir</span>[i][1]] = 1;<br>            &#125;<br><br>            dfs(tx, <span class="hljs-keyword">ty</span>, cnt + 1);<br>            square[tx + <span class="hljs-keyword">dir</span>[i][0]][<span class="hljs-keyword">ty</span> + <span class="hljs-keyword">dir</span>[i][1]] = 1;<br>        &#125;<br><br>    &#125;<br>&#125;<br>int main() &#123;<br>    min_steps = INT_MAX;<span class="hljs-comment">//记录结果</span><br>    <span class="hljs-comment">//输入</span><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; w &gt;&gt; <span class="hljs-keyword">h</span> &amp;&amp; (w + <span class="hljs-keyword">h</span>)) &#123;<br>        <span class="hljs-keyword">for</span> (int i = 1; i &lt;= w; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = 1; j &lt;= <span class="hljs-keyword">h</span>; j++) &#123;<br>                cin &gt;&gt; square[i][j];<br>                <span class="hljs-keyword">if</span> (square[i][j] == 2) &#123;<br>                    sx = i;<br>                    sy = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        dfs(sx, sy, 0);<br>        min_steps &lt;= 10 ? cout &lt;&lt; min_steps : cout &lt;&lt; &#x27;-1&#x27;;<br>    &#125;<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">13 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff">1<br>4<br><span class="hljs-deletion">-1</span><br>4<br>10<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3009"><a href="#http-poj-org-problem-id-3009" class="headerlink" title="http://poj.org/problem?id=3009"></a><a href="http://poj.org/problem?id=3009">http://poj.org/problem?id=3009</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-1321</title>
    <url>/2023/03/09/POJ-1321/</url>
    <content><![CDATA[<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">12</span>;<br><span class="hljs-keyword">int</span> n, k;<br><span class="hljs-keyword">char</span> b[N][N];<br><span class="hljs-keyword">bool</span> visr[N], visc[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(visr, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visr));<br>    <span class="hljs-built_in">memset</span>(visc, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visc));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> col, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == k) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (b[i][j] == <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; !visc[j] &amp;&amp; !visr[i]) &#123;<br>                visr[i] = visc[j] = <span class="hljs-number">1</span>;<br>                res += <span class="hljs-built_in">dfs</span>(j + <span class="hljs-number">1</span>, cnt + <span class="hljs-number">1</span>);<br>                visr[i] = visc[j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k &amp;&amp;  n != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                cin &gt;&gt; b[i][j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;	<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">2 1<br><span class="hljs-comment">#.</span><br>.<span class="hljs-comment">#</span><br>4 4<br><span class="hljs-string">...</span><span class="hljs-comment">#</span><br><span class="hljs-string">..</span><span class="hljs-comment">#.</span><br>.<span class="hljs-comment">#..</span><br><span class="hljs-comment">#...</span><br>-1 -1<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">2<br>1<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-1321"><a href="#http-poj-org-problem-id-1321" class="headerlink" title="http://poj.org/problem?id=1321"></a><a href="http://poj.org/problem?id=1321">http://poj.org/problem?id=1321</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3278</title>
    <url>/2023/03/10/POJ-3278/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.找最短路径 一般用bfs<br>2.三种状态 +1 -1 *2</p>
<span id="more"></span>
<h3 id="代码-注释（应该无需）"><a href="#代码-注释（应该无需）" class="headerlink" title="代码 + 注释（应该无需）"></a>代码 + 注释（应该无需）</h3><figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>using namespace std;<br>const int <span class="hljs-symbol">MAXN</span> = <span class="hljs-number">10000</span>;<br>bool vis[<span class="hljs-symbol">MAXN</span>];<br>int que[<span class="hljs-symbol">MAXN</span>][<span class="hljs-number">2</span>];<br>int front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br>int <span class="hljs-symbol">N</span>, <span class="hljs-symbol">K</span>;<br>void bfs() &#123;<br>    while (rear &lt; front) &#123;<br>        int x = que[rear][<span class="hljs-number">0</span>], t = que[rear++][<span class="hljs-number">1</span>];<br>        if (x == <span class="hljs-symbol">K</span>) &#123;<br>            cout &lt;&lt; t &lt;&lt; endl;<br>            return;<br>        &#125;<br>        if (x + <span class="hljs-number">1</span> &lt;= <span class="hljs-symbol">MAXN</span> &amp;&amp; !vis[x + <span class="hljs-number">1</span>]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = x + <span class="hljs-number">1</span>;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[x + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        if (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; !vis[x - <span class="hljs-number">1</span>]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = x - <span class="hljs-number">1</span>;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[x - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        if (<span class="hljs-number">2</span> * x &lt;= <span class="hljs-symbol">MAXN</span> &amp;&amp; !vis[<span class="hljs-number">2</span> * x]) &#123;<br>            que[front][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> * x;<br>            que[front++][<span class="hljs-number">1</span>] = t + <span class="hljs-number">1</span>;<br>            vis[<span class="hljs-number">2</span> * x] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br>int main() &#123;<br>    cin &gt;&gt; <span class="hljs-symbol">N</span> &gt;&gt; <span class="hljs-symbol">K</span>;<br>    que[front][<span class="hljs-number">0</span>] = <span class="hljs-symbol">N</span>; que[front++][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    vis[<span class="hljs-symbol">N</span>] = <span class="hljs-number">1</span>;<br>    bfs();<br>    system(<span class="hljs-string">&quot;pause&quot;</span>);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">17</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3278"><a href="#http-poj-org-problem-id-3278" class="headerlink" title="http://poj.org/problem?id=3278"></a><a href="http://poj.org/problem?id=3278">http://poj.org/problem?id=3278</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3126</title>
    <url>/2023/03/13/POJ-3126/</url>
    <content><![CDATA[<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>1.首先需要判断素数，而每次判断很耗时间，所以使用素数筛打表,此处使用欧拉筛<br>2.找最短路径则一般使用bfs</p>
<span id="more"></span>
<p>欧拉筛</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">int prime<span class="hljs-comment">[10005]</span>;<br>bool isprime<span class="hljs-comment">[10005]</span>;<br>void getPrime() &#123;<br>    for (int i = 0; i &lt;= 10000; i++) &#123;<br>        isprime<span class="hljs-comment">[i]</span> = 1;<br>    &#125;<br>    for (int i = 2; i &lt;= 10000; i++) &#123;<br>        if (isprime<span class="hljs-comment">[i]</span>) &#123;<br>            prime<span class="hljs-comment">[cnt++]</span> = i;<br>        &#125;<br>        for (int j = 1; j &lt; cnt &amp;&amp; i * prime<span class="hljs-comment">[j]</span> &lt;= 10000; j++) &#123;<br>            isprime<span class="hljs-comment">[prime<span class="hljs-comment">[j]</span> * i]</span> = 0;<br>            if (i % prime<span class="hljs-comment">[j]</span> == 0) break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">bool</span> isprime[<span class="hljs-number">10005</span>];<br><span class="hljs-keyword">int</span> vis[<span class="hljs-number">10000</span>];<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">state</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    string s;<br>    <span class="hljs-keyword">int</span> step;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPrime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>        isprime[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (isprime[i]) &#123;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; cnt &amp;&amp; i * prime[j] &lt;= <span class="hljs-number">10000</span>; j++) &#123;<br>            isprime[prime[j] * i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">s_to_int</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        res = res * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    queue&lt;state&gt; q;<br>    state st;<br>    st.s = s; st.step = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(st);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        state tmp = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">compare</span>(tmp.s) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> tmp.step;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                state t = tmp;<br>                t.step++;<br>                t.s[i] = j + <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>                <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">s_to_int</span>(t.s);<br>                <span class="hljs-keyword">if</span> (!vis[num] &amp;&amp; isprime[num] == <span class="hljs-number">1</span>) &#123;<br>                    vis[num] = <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(t);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">getPrime</span>();<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>        string s, t;<br>        cin &gt;&gt; s &gt;&gt; t;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">bfs</span>(s, t);<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1033 </span><span class="hljs-number">8179</span><br><span class="hljs-symbol">1373 </span><span class="hljs-number">8017</span><br><span class="hljs-symbol">1033 </span><span class="hljs-number">1033</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">6<br>7<br>0<br></code></pre></td></tr></table></figure>
<h3 id="http-poj-org-problem-id-3126"><a href="#http-poj-org-problem-id-3126" class="headerlink" title="http://poj.org/problem?id=3126"></a><a href="http://poj.org/problem?id=3126">http://poj.org/problem?id=3126</a></h3>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>POJ-3414</title>
    <url>/2023/03/14/POJ-3414/</url>
    <content><![CDATA[<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>1.给出两个瓶子的容量（a,b）和一个目标容量(c) 有三种操作<br>FILL(i)        fill the pot i (1 ≤ i ≤ 2) from the tap;<br>DROP(i)      empty the pot i to the drain;<br>POUR(i,j)    pour from pot i to pot j; after this operation either the pot j is full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j)<br>2. 标记状态 有六种转化 F1,F2,D1,D2,P12,P21</p>
<span id="more"></span>
<h2 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-keyword">int</span> prior[N * N], res[N * N];<span class="hljs-comment">//记录前一个的操作</span><br><span class="hljs-keyword">int</span> vis[N][N];<br><span class="hljs-keyword">int</span> a, b, c;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a, b, cur, step;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> s = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(a), <span class="hljs-built_in">b</span>(b), <span class="hljs-built_in">cur</span>(c), <span class="hljs-built_in">step</span>(s) &#123;&#125;;<br>&#125;;<br>queue&lt;node&gt; q;<br><br><span class="hljs-comment">//输出路径 </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prior[cur] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">solve</span>(prior[cur]);<br>    <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;DROP(1)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FILL(1)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;POUR(1,2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">4</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;DROP(2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">5</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FILL(2)&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[cur] == <span class="hljs-number">6</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;POUR(2,1)&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    prior[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>());<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        node t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (t.a == c || t.b == c) &#123;<br>            cout &lt;&lt; t.step &lt;&lt; endl;<br>            <span class="hljs-built_in">solve</span>(t.cur);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//6种状态</span><br>        <span class="hljs-keyword">int</span> sum = t.a + t.b;<br>        <span class="hljs-keyword">if</span> (t.a) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[<span class="hljs-number">0</span>][t.b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, t.b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur; vis[<span class="hljs-number">0</span>][t.b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> mb = b - t.b;<br>            <span class="hljs-keyword">if</span> (t.a &lt; mb &amp;&amp; !vis[<span class="hljs-number">0</span>][sum]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">0</span>, sum, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[<span class="hljs-number">0</span>][sum] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.a &gt;= mb &amp;&amp; !vis[t.a - mb][b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a - mb, b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a - mb][b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.a != a &amp;&amp; !vis[a][t.b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(a, t.b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[a][t.b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t.b) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[t.a][<span class="hljs-number">0</span>]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a, <span class="hljs-number">0</span>, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">4</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> ma = a - t.a;<br>            <span class="hljs-keyword">if</span> (t.b &lt; ma &amp;&amp; !vis[sum][<span class="hljs-number">0</span>]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(sum, <span class="hljs-number">0</span>, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[sum][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">6</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t.b &gt;= ma &amp;&amp; !vis[a][t.b - ma]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(a, t.b - ma, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[a][t.b - ma] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">6</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (t.b != b &amp;&amp; !vis[t.a][b]) &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(t.a, b, ++cnt, t.step+<span class="hljs-number">1</span>));<br>                prior[cnt] = t.cur, vis[t.a][b] = <span class="hljs-number">1</span>;<br>                res[cnt] = <span class="hljs-number">5</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">bfs</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">6</span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">DROP</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">FILL</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">POUR</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/10/14/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="逻辑位运算符"><a href="#逻辑位运算符" class="headerlink" title="逻辑位运算符"></a>逻辑位运算符</h3><p>&amp; - 位与 100 | 101 = 100<br>| - 位或 100 | 101 = 101<br>^ - 异或 100 | 101 = 001<br>~ - 按位取反  100 = 011</p>
<h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p><code>左移</code>  100 &lt;&lt; 1 = 1000<br><code>右移</code>  100 &gt;&gt; 1 = 10</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="2的幂（简单）"><a href="#2的幂（简单）" class="headerlink" title="2的幂（简单）"></a>2的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-two/">https://leetcode.cn/problems/power-of-two/</a></p>
<p>如果一个数n是2的幂，那么二进制下的样子应该是 10,100,1000……<br>那么n - 1就是 01 011 0111，此时对 n 和 n - 1进行 <code>&amp;</code> 操作<br>按照规则，得到的是 00,000,0000,所以只需要判断 (n &amp; (n - 1))等于0即可</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfTwo(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4的幂（简单）"><a href="#4的幂（简单）" class="headerlink" title="4的幂（简单）"></a>4的幂（简单）</h3><p><a href="https://leetcode.cn/problems/power-of-four/">https://leetcode.cn/problems/power-of-four/</a></p>
<p>如果n是4的幂,就代表 4^x == n –&gt;  2^2x == n<br>所以4的幂一定是2的幂，但是2的幂不一定是4的幂，如2^(2x + 1);<br>那么为了区分 2^2x 和 2^(2x + 1),则可以用 mod 3,前者会等于1,后者等于2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isPowerOfFour(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (n % <span class="hljs-number">3</span>) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><p><a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>如 1011<br>1、 每次&amp;1 然后 右移<br>2、 n = 1011  n - 1 = 1010 所以 n &amp; (n - 1) = 1010 即消去了最后的1,只需重复这个操作</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 方法2</span><br>    <span class="hljs-built_in">int</span> hammingWeight(<span class="hljs-built_in">uint</span>32_t n) &#123;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交换数字（中等）"><a href="#交换数字（中等）" class="headerlink" title="交换数字（中等）"></a>交换数字（中等）</h3><p><a href="https://leetcode.cn/problems/swap-numbers-lcci/">https://leetcode.cn/problems/swap-numbers-lcci/</a></p>
<p>要求交换 a, b 且不用临时变量，我懂了，那我直接调函数！<br>漏~ 异或<code>^</code>运算登场<br>    异或的基本操作 a ^ a = 0<br>                   a ^ 0 = a<br>                   a ^ b = b ^ a<br>只需三步：<br>    a = a ^ b; // a = a ^ b<br>    b = a ^ b; // b = (a) ^ b = (展开)(a ^ b) ^ b = a,此时 b = a了<br>    a = a ^ b; // a = (a) ^ (b) = a ^ b ^ a = b；<br>很抽象，但是你细品。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">class Solution &#123;<br>public:<br>    vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) &#123;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[1]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        numbers<span class="hljs-comment">[0]</span> = numbers<span class="hljs-comment">[0]</span> ^ numbers<span class="hljs-comment">[1]</span>;<br>        return numbers;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字（简单）"><a href="#只出现一次的数字（简单）" class="headerlink" title="只出现一次的数字（简单）"></a>只出现一次的数字（简单）</h3><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<p>异或<code>^</code> : 我又来喽~<br>    基本操作之 – a ^ a = 0<br>直接所有的都异或一遍, 最后得到的就是结果(因为所有的couple都被消了, 独留单身狗)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-II-（中等）"><a href="#只出现一次的数字-II-（中等）" class="headerlink" title="只出现一次的数字 II （中等）"></a>只出现一次的数字 II （中等）</h3><p><a href="https://leetcode.cn/problems/single-number-ii/">https://leetcode.cn/problems/single-number-ii/</a></p>
<p>稍微修改一下, 所有的couple都变成三人行了。不对劲,不对劲,不对劲。<br>没办法异或了, 每个数都是int型, 也就是32位, 那就对所有数的每一位单独处理<br>看一下所有数在某一位上的1的个数<br>                3个 : 代表他们三个是出现了3次的, 单独的那个在这一位上没有信息(1)<br>                4个 ：说明单独的那个在这一位有信息<br>很合理！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>                cnt += (n &gt;&gt; i) &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 获取所有数在第i位上1的总数</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">3</span>) &#123;<br>			<span class="hljs-comment">// 1 &lt;&lt; i是左移运算符, 就是把1往左移动i位</span><br>			<span class="hljs-comment">// 1 &lt;&lt; 2 = 100,然后在用 res 进行 | 操作, 就会把res的第i位 变成1</span><br>                res |= (<span class="hljs-number">1</span> &lt;&lt; i); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="只出现一次的数字-III（中等）"><a href="#只出现一次的数字-III（中等）" class="headerlink" title="只出现一次的数字 III（中等）"></a>只出现一次的数字 III（中等）</h3><p><a href="https://leetcode.cn/problems/single-number-iii/">https://leetcode.cn/problems/single-number-iii/</a></p>
<p>这个也能出到3,真的是 无 语 死 啦~~(小潮音)<br>简单来说, 又回到了couple状态, 不过这次是两个单身狗了<br>一遍异或下来的结果是: 狗1 ^ 狗2, 怎么能分开呢？<br>        异或小提示：<br>            a ^ b = 0对于这个题是不可能的, 如果 = 0 他俩就是couple了<br>            a ^ b 的结果中肯定有一位是 1 且 a 和 b 在这一位上还不一样(异或某一位一样的话是 = 0)<br>就用这个把他们区分开来，开码！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>		<span class="hljs-comment">// num是所有异或后的结果</span><br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>            num ^= n;<br>        &#125;<br>		<span class="hljs-comment">// dif是最后一个1 如 1010  --&gt;  10</span><br>		<span class="hljs-comment">// 还要确保溢出问题</span><br>        <span class="hljs-keyword">int</span> dif = (num == INT_MIN ? num : num &amp; (-num));<br>        <span class="hljs-keyword">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>			<span class="hljs-comment">// 根据这一位来区分</span><br>            <span class="hljs-keyword">if</span> (n &amp; dif) &#123;<br>                res1 ^= n;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res2 ^= n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;res1, res2&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>吐槽一下： 要不是题目要求 <code>必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</code> 我是真想用哈希表啊,我差那点空间吗！！！</p>
<h3 id="汉明距离（简单）"><a href="#汉明距离（简单）" class="headerlink" title="汉明距离（简单）"></a>汉明距离（简单）</h3><p><a href="https://leetcode.cn/problems/hamming-distance/">https://leetcode.cn/problems/hamming-distance/</a></p>
<p>来个简单题休息一下,就是异或然后看1的个数。</p>
<p>复习：<br>    异或 : 相同为0,不同是1<br>    与 : n &amp; (n - 1) 很常用, 消除最后一位1</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>public:<br>    <span class="hljs-built_in">int</span> hammingDistance(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> = x ^ y;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">num</span>) &#123;<br>            <span class="hljs-built_in">num</span> = <span class="hljs-built_in">num</span> &amp; (<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>);<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="交替位二进制数（简单）"><a href="#交替位二进制数（简单）" class="headerlink" title="交替位二进制数（简单）"></a>交替位二进制数（简单）</h3><p><a href="https://leetcode.cn/problems/binary-number-with-alternating-bits/">https://leetcode.cn/problems/binary-number-with-alternating-bits/</a></p>
<p>先转换成二进制,然后挨着判断相邻的一不一样，歪瑞EZ啊</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> hasAlternatingBits(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span> || (n &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>位运算</category>
      </categories>
  </entry>
</search>
